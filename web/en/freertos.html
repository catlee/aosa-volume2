<html>
  <head>
    <meta name="provenance" content="$Id$" />
    <link rel="stylesheet" href="aosa.css" type="text/css" />
    <title>The Architecture of Open Source Applications, Volume 2: FreeRTOS</title>
  </head>
  <body>

    <div class="header">
      <table>
	<tr>
	  <td>
	    <a href="index.html"><img src="../images/titlebar.jpg" alt="The Architecture of Open Source Applications, Volume 2" /></a>
	  </td>
	  <td>
	    <strong><em>The Architecture of Open Source Applications, Volume 2</em></strong>
	    <br/>
	    <strong>Amy Brown and Greg Wilson (eds.)</strong>
	  </td>
	</tr>
      </table>
      <h1 class="chaptitle">FreeRTOS</h1>
      <h1 class="chapterauthor"><a href="intro.html#svec-christopher">Christopher Svec</a></h1>
    </div>

<p>
EDIT: First, some sections read like a brain dump --- e.g., the opening is a lot of interesting material, in what appears to be a random order :-)  I think it's important for readers new to FreeRTOS to find a narrative thread, or a main point or two that you want to highlight that everything else can be structured around.  In your case, I think it might be that there's one core activity ("schedule next activity") that everything else exists to support, and that the whole design of FreeRTOS can be seen as superstructure for that.  If so, say that up front, and keep coming back to it.
</p>

<p>
FreeRTOS is an open source real-time operating system (RTOS) for embedded systems.
</p>

<p>
Like all operating systems, FreeRTOS's main job is to run tasks. Most of 
FreeRTOS's code involves prioritizing, scheduling, and running user-defined 
tasks.
</p>

<p>
Unlike all operating systems, FreeRTOS is a real-time operating system which runs 
on embedded systems.
</p>

<p>
"Real-time" and "embedded" can mean different things to different people, so let's 
define them.
</p>

<p>
Embedded systems are computer systems that are designed to do only a few things, 
like a TV remote control, in-car GPS system, digital watch, or a pacemaker.
</p>

<p>
Embedded systems are typically smaller and slower than general purpose computer 
systems, and are also usually less expensive. A typical low-end embedded system may 
have an 8-bit CPU running at 25MHz, a few KB of RAM, and maybe 32KB of flash memory.  
A higher-end embedded system may have a 32-bit CPU running at 750MHz, a GB of RAM, 
and multiple GB of flash memory.
</p>

<p>
Real-time systems are designed to do something within a certain amount of
time: Real-time systems guarantee that stuff happens when it's supposed to.
</p>

<p>
A pacemaker is an excellent example of a real-time embedded system. A pacemaker 
must contract the heart muscle at the right time to keep you alive. It can't be too 
busy to respond in time. Pacemakers and other real-time embedded systems are 
carefully designed to run their tasks on time, every time.
</p>

<p>
Because FreeRTOS is a real-time operating system for embedded systems, it is small, 
simple, and reliable. A typical binary code image is less than 10KB.
</p>

<p>
FreeRTOS's web site<sup class="footnote"><a href="#footnote-1">1</a></sup> sums it 
up like this:
</p>

<p>
"FreeRTOS(tm) includes official ports to 27 architectures [and 17 toolchains] and 
receives more than 77,500 downloads a year. It is market leading, robust, supported, 
portable, open source, free to download, and free to deploy.  FreeRTOS can be used in 
commercial applications without any requirement to expose your proprietary source 
code. With a growing ecosystem, FreeRTOS is commonly integrated with both open source 
and commercial TCP/IP, file system, and USB components."
</p>

<p>
This chapter discusses FreeRTOS version 7.0.1, released on May 13, 2011.
</p>

<p>
FreeRTOS is under active development, and has been since Richard Barry started 
work on it in 2002.
</p>

<p>
As for me, I'm not a developer of or contributor to FreeRTOS (yet, anyway), I'm 
merely a user and a fan. As a result, this chapter will favor the "what" and "how" of 
FreeRTOS's architecture, with less of the "why" than other chapters in this book.
</p>

<p>
By the end of this chapter I hope that you'll understand the basic architecture of 
FreeRTOS. Most of FreeRTOS is dedicated to running tasks, so you'll get a good look 
at exactly how FreeRTOS does that.
</p>

<p>
If this is your first look under the hood of an operating system, I also hope that 
you'll learn the basics about how any OS works. FreeRTOS is relatively simple, 
especially when compared to Windows, Linux, or OS X, but all operating systems share 
the basic concepts and goals, and so looking at any OS can be very instructive and 
interesting.
</p>

<div class="sect">
<h2>999.2. Architecture Overview</h2>

<div class="subsect">
<h3>999.2.1. FreeRTOS Organization</h3>

<p>
FreeRTOS is a relatively small application. The minimum core of FreeRTOS is in three 
source (.c) files and a handful of header files, totalling just under 9000 lines of 
code, including comments and blank lines.
</p>

<p>
FreeRTOS's code breaks down into three main areas: tasks, communication, and hardware 
interfacing.
</p>

<div class="subsubsect">
<h4>999.2.1.1. Job Number One: Jobs. Err, Tasks.</h4>

<p>
Almost half of FreeRTOS's core code deals with the central figure in many operating 
systems: tasks.
</p>

<p>
Tasks, jobs, applications, call them what you like, but FreeRTOS calls them
tasks.
</p>

<p>
<code>tasks.c</code> and <code>task.h</code> do all the heavy lifting for 
creating, scheduling, and maintaining tasks.
</p>

</div>

<div class="subsubsect">
<h4>999.2.1.2. Job Number Two: I can't hear you... Communication!</h4>

<p>
Tasks are good, but tasks that can communicate with each other are even better!  
Which brings us to the second largest FreeRTOS job: communication. About 40% of 
FreeRTOS's core code deals with communication.
</p>

<p>
<code>queue.c</code> and <code>queue.h</code> handle most FreeRTOS communication.  
Tasks and interrupts use queues to send data to each other and to signal the use of 
critical resources using semaphores and mutexes.
</p>

</div>

<div class="subsubsect">
<h4>999.2.1.3. Job Number Three: The Hardware Whisperer</h4>

<p>
The ~9000 lines of code that make up the base of FreeRTOS are processor 
independent.  They don't talk directly to the hardware, they aren't aware of the 
underlying hardware or processor architecture at all.  The same code runs no matter 
what processor FreeRTOS is running on, from the humble 8051 to the newest, shiniest 
ARM core.
</p>

<p>
About 6% of FreeRTOS's core code acts a shim between the processor-independent 
FreeRTOS core and the processor-dependent code.
</p>

<p>
Table 1 summarizes the FreeRTOS core code.
</p>

<div class="table" id="tbl.freertos.files">
  <table>
  <tr>
    <th>Function</th><th>Lines of Code</th><th>Percent of Core FreeRTOS</th>
  </tr>
  <tr><td>Tasks</td><td>4340</td><td>48%</td></tr>
  <tr><td>Communication</td><td>3526</td><td>39%</td></tr>
  <tr><td>Hardware Interfacing</td><td> 570</td><td>6%</td></tr>
  <tr><td>Misc.</td><td> 551</td><td>6%</td></tr>
  <tr><td>Total</td><td>8987</td><td>100%</td></tr>
<!-- Here are the original files/counts, left in comments for later reference:
  <tr><td><code>FreeRTOS.h   </code></td><td> 468</td></tr> - config
  <tr><td><code>projdefs.h   </code></td><td>  83</td></tr> - config
  <tr><td><code>StackMacros.h</code></td><td> 174</td></tr> - hw    
  <tr><td><code>portable.h   </code></td><td> 396</td></tr> - hw    
  <tr><td><code>queue.c      </code></td><td>1539</td></tr> - comm  
  <tr><td><code>queue.h      </code></td><td>1270</td></tr> - comm  
  <tr><td><code>semphr.h     </code></td><td> 717</td></tr> - comm  
  <tr><td><code>list.c       </code></td><td> 197</td></tr> - tasks 
  <tr><td><code>list.h       </code></td><td> 314</td></tr> - tasks 
  <tr><td><code>tasks.c      </code></td><td>2522</td></tr> - tasks 
  <tr><td><code>task.h       </code></td><td>1307</td></tr> - tasks 
-->

</table>
</div>

</div>

</div>

<div class="subsect">
<h3>999.2.2. Hardware Considerations</h3>

<p>
EDIT: Sec. 999.2.2: "since it runs on 27+ chip architectures" --- repetition.  What I 
_really_ want here is some discussion of how this cross-chip portability affects the 
architecture: is everything neatly encapsulated inside leaf-node #ifdef's?  If so, 
wow, that must have taken a lot of work to arrange --- how did the rest of the 
architecture have to be bent and shaped to make that possible?
</p>

<p>
If the processor independent FreeRTOS code doesn't talk to the hardware, then who 
does?  Why, the processor dependent FreeRTOS code, of course!
</p>

<p>
The processor independent FreeRTOS layer sits on top of a processor dependent 
layer.  This processor dependent layer knows how to talk to whatever chip 
architecture and compiler toolchain you choose.
</p>

<div class="figure" id="fig.freertos.layers">
  <img src="../images/freertos/freertos_layers.jpg" alt="[Obligatory picture of FreeRTOS software layers]" />
  Figure&nbsp;999.1: Obligatory picture of FreeRTOS software layers
</div>

<p>
FreeRTOS ships with all the processor independent as well as processor dependent 
code you'll need to get a system up and running. It supports many compilers 
(CodeWarrior, GCC, IAR, SDCC, etc.) as well as many processor architectures (ARM7, 
ARM Cortex-M3, various PICs, Silicon Labs 8051, x86, etc.). See the FreeRTOS website 
for all supported architectures and compilers.
</p>

<p>
FreeRTOS is highly configurable by design. FreeRTOS can be built as a single CPU, 
bare-bones, stripped down RTOS, supporting only a few tasks, or it can be built as a 
highly functional multicore beast with TCP/IP, a file system, and USB.
</p>

<p>
Configuration options are selected in <code>FreeRTOSConfig.h</code> by setting 
various <code>#defines</code>. Clock speed, heap size, mutexes, and API subsets are 
all configurable in this file, along with a ton of other options.
</p>

<p>
Many of FreeRTOS's functions are defined as C preprocessor macros using 
<code>#defines</code>.  For non-embedded applications this is a cardinal sin, but in 
many smaller embedded systems the overhead for calling a function is not worth the 
advantages that "real" functions offer.
</p>

</div>

</div>

<div class="sect">
<h2>999.3. FreeRTOS Data Structures</h2>

<p>
Now that we have the high level overview out of the way, let's dive in to the 
details.
</p>

<p>
In his book "The Mythical Man-Month," [<a 
  href="bibliography.html#bib:brooks:freertos">Bro95</a>] Fred Brooks famously says: 
"Show me your flowcharts and conceal your tables, and I shall continue to be 
mystified.  Show me your tables, and I won't usually need your flowcharts; they'll be 
obvious."
</p>

<p>
The modern-day equivalent of this quote is "Show me your data structures and I 
won't need your algorithms, they'll be obvious."
</p>

<p>
I don't think FreeRTOS's algorithms are necessarily obvious if you understand only 
the data structures, but understanding FreeRTOS's data structures is a good place to 
start.
</p>

<p>
We'll look at the three main FreeRTOS data structures: Tasks, Lists, and 
Queues.
</p>

<div class="subsect">
<h3>999.3.1. Caveats</h3>

<p>
Many of FreeRTOS's basic data types are processor dependent <code>typedefs</code> 
or <code>#defines</code>.  I've changed those <code>typedefs</code> and 
<code>#defines</code> to a common data type to make this chapter more readable.
</p>

<p>
For instance, the basic task priority level data type is 
<code>portBASE_TYPE</code>.  This type usually resolves to an <code>unsigned 
  short</code> or an <code>unsigned long</code> type, but I'm simply going to call it 
an <code>unsigned int</code>.  This gets the point across without getting bogged down 
in unfamiliar <code>portBASE_TYPE</code>, <code>portSTACK_TYPE</code>, and 
<code>portTickType</code> definitions, and also lets us ignore whether a type is a 
<code>short</code> or <code>long</code>. For our purposes it just doesn't matter.
</p>

<p>
Also, I'm going to omit some optional data structure members for clarity's 
sake.
</p>

<p>
EDIT: And are you sure you can't show actual code?  Do the optional parts of data 
structures not give insight into architecture?
</p>

<p>
Don't be surprised if the actual FreeRTOS code looks a bit different than what is 
shown here. The changes are aesthetic only, no content was harmed in the making of 
this chapter.
</p>

</div>

<div class="subsect">
<h3>999.3.2. Tasks</h3>

<p>
The main job of all operating systems is to run and coordinate user tasks.
</p>

<p>
Like many operating systems, the basic unit of work in FreeRTOS is "the task." 
</p>


<p>
EDIT: Task control block: would this work better as a block diagram, rather than a code snippet?  Or would both together be useful?
</p>

<p>
FreeRTOS uses a Task Control Block (TCB) to represent each task. The TCB is 
defined in tasks.c like this:
</p>

<pre>
/*
 * Task control block.  A task control block (TCB) is allocated to each task,
 * and stores the context of the task.
 */
typedef struct tskTaskControlBlock
{
  volatile unsigned int *pxTopOfStack;                   /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE STRUCT. */
                                                         
  xListItem    xGenericListItem;                         /*< List item used to place the TCB in ready and blocked queues. */
  xListItem    xEventListItem;                           /*< List item used to place the TCB in event lists.  */
  unsigned int uxPriority;                               /*< The priority of the task where 0 is the lowest priority. */
  unsigned int   *pxStack;                               /*< Points to the start of the stack. */
  signed char    pcTaskName[ configMAX_TASK_NAME_LEN ];  /*< Descriptive name given to the task when created.  Facilitates debugging only. */

  #if ( portSTACK_GROWTH > 0 )
    unsigned int *pxEndOfStack;                          /*< Used for stack overflow checking on architectures where the stack grows up from low memory. */
  #endif

  #if ( configUSE_MUTEXES == 1 )
    unsigned int uxBasePriority;                         /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
  #endif

} tskTCB;
</pre>

<p>
The TCB stores the address of the stack start address in <code>pxStack</code> and 
the current top of stack in <code>pxTopOfStack</code>. It also stores a pointer to 
the end of the stack in <code>pxEndOfStack</code> to check for stack overflow if the 
stack grows "up" to higher addresses. If the stack grows "down" to lower addresses 
then stack overflow is checked by comparing the current top of stack against the 
start of stack memory in <code>pxStack</code>.
</p>

<p>
The TCB stores the initial priority of the task in <code>uxPriority</code> and 
<code>uxBasePriority</code>. A task is given a priority when it is created. Higher 
priority tasks will be given priority over lower priority tasks. A task's priority 
can be changed.  If FreeRTOS implements priority inheritance then it uses 
<code>uxBasePriority</code> to remember the original priority while the task is 
temporarily elevated to the "inherited" priority. (See the discussion about mutexes 
below for more on priority inheritance.)
</p>

<p>
0 is the lowest priority. The highest priority is user-configurable at compile 
time.  The scheduler allocates a ready list for each priority level, so use as few 
priority levels as possible to reduce memory usage.
</p>

<p>
EDIT: "The xGenericListItem and xEventListItem live for the lifetime of the task and are inserted into and remove[d] from lists as the task carries out its work."  Definitely not clear at this point, but later, when you explain how queues are handled, it starts to make sense.  Rearrange?
</p>

<p>
Each task has two list items for use in FreeRTOS's various scheduling lists. The 
<code>xGenericListItem</code> and <code>xEventListItem</code> live for the lifetime 
of the task and are inserted into and remove from lists as the task carries out its 
work.
</p>

<p>
Interestingly, the TCB structure doesn't have a field that keeps track of the 
state of the task.
</p>

<p>
A task can be in one of four states: running, ready to run, suspended, or blocked.  
You might expect each task to have a variable that tells FreeRTOS what the task is 
doing. Instead, however, FreeRTOS tracks task state implicitly by putting tasks in 
the appropriate list: ready list, suspended list, etc.
</p>

<p>
EDIT: "...without needing to explicitly maintain a state variable."  Later, you explain that the pointer to the queue the item is in is (implicitly) its state; say that explicitly (and possibly provide a forward ref?).
</p>

<p>
As a task changes from one state to another, FreeRTOS simply moves it from one 
list to another, without needing to explicitly maintain a state variable.
</p>

</div>

<div class="subsect">
<h3>999.3.3. Lists</h3>

<p>
FreeRTOS uses a list structure to keep track of tasks for scheduling, and also to 
implement its queues.
</p>

<p>
The FreeRTOS list is a standard circular doubly linked list with a couple of 
interesting additions. Here's a list element:
</p>

<pre>
struct xLIST_ITEM
{
  unsigned int xItemValue;                  /*< The value being listed.  In most cases this is used to sort the list in descending order. */
  volatile struct xLIST_ITEM * pxNext;      /*< Pointer to the next xListItem in the list.  */
  volatile struct xLIST_ITEM * pxPrevious;  /*< Pointer to the previous xListItem in the list. */
  void * pvOwner;                           /*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
  void * pvContainer;                      /*< Pointer to the list in which this list item is placed (if any). */
};
</pre>

<p>
Each list element holds a number, <code>xItemValue</code>, that is the priority of 
the task being tracked.
</p>

<p>
Lists are kept in high-to-low priorty order, meaning that the highest priority 
xItemValue (the largest number) is at the front of the list and the lowest priority 
xItemValue (the smallest number) is at the end of the list.
</p>

<p>
The <code>pxNext</code> and <code>pxPrevious</code> pointers are standard list 
pointers.
</p>

<p>
EDIT: "pvOwner allows a list walking function..." Hm --- only one such function can be active at a time, i.e., the list-walking code is non-reentrant?  If that's the case, say so explicitly, and talk about why that's possible in a concurrent system.
</p>

<p>
<code>pvOwner</code> is a pointer to the owner of the list element. This is 
usually a task's TCB object. <code>pvOwner</code> allows a list walking function to 
quickly get to the task who's priority this list element is for.
</p>

<p>
<code>pvContainer</code> points to the list that this item is in. It is used to 
quickly determine if a list item is in a particular list.
</p>

<p>
Each list element can be put in a list, which is defined as:
</p>

<pre>
typedef struct xLIST
{
  volatile unsigned int uxNumberOfItems;
  volatile xListItem * pxIndex;          /*< Used to walk through the list.  Points to the last item returned by a call to pvListGetOwnerOfNextEntry (). */
  volatile xMiniListItem xListEnd;       /*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
} xList;
</pre>

<p>
The size of a list at any time is stored in <code>uxNumberOfItems</code> for fast 
list size operations.
</p>

<p>
Most "traditional" list accesses you've ever used probably do all of their work 
within a single for() loop or function call like this:
</p>

<pre>
for (listPtr = listStart; listPtr != NULL; listPtr = listPtr->next) {
  // Do something with listPtr here...
}
</pre>

<p>
FreeRTOS frequently needs to access a list across multiple for() and while() 
loops, and so it uses list functions that manipulate the <code>pxIndex</code> pointer 
to walk the list. The list function <code>listGET_OWNER_OF_NEXT_ENTRY</code> 
(actually a macro), does <code>pxIndex = pxIndex->pxNext;</code> and returns 
<code>pxIndex</code>. (Of course it does the proper wraparound detection too.) This 
way the list itself is responsible for keeping track of "where you are" while walking 
it using <code>pxIndex</code>, allowing the rest of FreeRTOS to not worry about 
it.
</p>

<p>
EDIT: "xListEnd contains the maximum priority value."  Can other items have this value as well, or is there a "reserved" maximum value for this purpose?
</p>

<p>
All new lists contain a single element: the <code>xListEnd</code> element.  
<code>xListEnd</code> contains the maximum priority value.
</p>
 
<p>
Since lists are sorted high-to-low, the <code>xListEnd</code> element is used as a 
marker for the start of the list.  And since the list is circular, this 
<code>xListEnd</code> element is also a marker for the end of the list.
</p>

<p>
The scheduler has an array of lists, one list for each priority level:
</p>

<pre>
static xList pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready tasks.  */
</pre>

<p>
The scheduler also has a variety of other lists that are used for tasks that are 
not in the ready state (suspended, etc.).
</p>

</div>

<div class="subsect">
<h3>999.3.4. Queues</h3>

<p>
FreeRTOS allows tasks and ISRs to communicate and synchronize with each other 
using queues.
</p>

<p>
The basic queue data structure is:
</p>

<pre>
/*
 * Definition of the queue used by the scheduler.
 * Items are queued by copy, not reference.
 */
typedef struct QueueDefinition
{
  signed char *pcHead;                     /*< Points to the beginning of the queue storage area. */
  signed char *pcTail;                     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
                                           
  signed char *pcWriteTo;                  /*< Points to the free next place in the storage area. */
  signed char *pcReadFrom;                 /*< Points to the last place that a queued item was read from. */
                                           
  xList xTasksWaitingToSend;               /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
  xList xTasksWaitingToReceive;            /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */

  volatile unsigned int uxMessagesWaiting; /*< The number of items currently in the queue. */
  unsigned int uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
  unsigned int uxItemSize;                 /*< The size of each items that the queue will hold. */
                                         
  signed int xRxLock;                      /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
  signed int xTxLock;                      /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
} xQUEUE;
</pre>

<p>
This is a fairly standard queue with head and tail pointers, as well as pointers 
to keep track of where we've just read from and written to.
</p>

<p>
EDIT: "...does a deep copy of the item into the queue's internal memory."  Why?
</p>

<p>
When creating a queue the user specifies the length of the queue and the size of 
each element in the queue. Adding an item into a queue does a deep copy of the item 
into the queue's internal memory.
</p>

<p>
FreeRTOS supports blocking and non-blocking queue insertions and removals.
</p>

<p>
EDIT: "Non-blocking operations return immediately..."  How?  How are delays implemented?  How are timeouts implemented?
</p>

<p>
Non-blocking operations return immediately with a "did the queue insert work?" or 
"did the queue remove work?" status.
</p>

<p>
Blocking operations are specified with a timeout. A task can block indefinitely or 
for a given amount of time.
</p>

<p>
In the "block indefinitely" case an insert operation blocks until there is space in 
the queue, and a remove operation blocks until there is at least one item in the 
queue. The insert/remove operation then returns with a "passed" status.
</p>

<p>
The "block for a given amount of time" case is similar, except that if an 
insert/remove operation isn't possible within the given amount of time the 
insert/remove returns with a "failed" status.
</p>

<p>
FreeRTOS uses the <code>xTasksWaitingToSend</code> list to keep track of tasks 
that are
blocking on inserting into the queue. Similarly, <code>xTasksWaitingToReceive</code>
keeps track of tasks that are blocking on removing from the queue.
</p>

<p>
The <code>xRxLock</code> and <code>xTxLock</code> elements are used for - you 
guessed it - locking a queue.  We'll look at those when we discuss the queueing 
algorithms later.
</p>

</div>

<div class="subsect">
<h3>999.3.5. Semaphores and Mutexes</h3>

<div class="subsubsect">
<h4>999.3.5.1. What's The Difference?</h4>

<p>
Semaphores and mutexes may sound like the same thing, but they're not. FreeRTOS 
implements them similarly, but they're intended to be used in different ways.
</p>

<p>
How should they be used differently? Embedded guru Michael Barr says it best here 
in his article, "Mutexes and Semaphores Demystified":<sup class="footnote"><a href="#footnote-3">3</a></sup>
</p>

<p>
EDIT: "By contrast, tasks that use semaphores..." I'm still confused after reading this.
</p>

<p>
"The correct use of a semaphore is for signaling from one task to another. A mutex 
is meant to be taken and released, always in that order, by each task that uses the 
shared resource it protects. By contrast, tasks that use semaphores either signal 
["send" in FreeRTOS terms] or wait ["receive" in FreeRTOS terms] - not both."
</p>

<p>
If you're at all in doubt about semaphores and mutexes please check out Michael's 
article.
</p>

</div>

<div class="subsubsect">
<h4>999.3.5.2. Implementation</h4>

<p>
FreeRTOS implements a binary semaphore as a one item queue. It doesn't store any 
actual data in the queue, it just cares if the queue is empty or full: it's doing 
"pure synchronization" as the FreeRTOS header file <code>semphr.h</code> calls it.  
Therefore the queue has a data size of zero bytes (<code>uxItemSize == 0</code>).
</p>

<p>
The binary semaphore is given and taken using short macros that call the normal 
queue functions.
</p>

<p>
A counting semaphore of length N is also accessed with thin give and take macros 
wrapped around the normal queue functions, but is implemented as an N-element queue.  
As with a binary semaphore, a counting semaphore's queue has a data size of zero 
bytes.
</p>

<p>
A mutex is also implemented as a queue, but several of the <code>xQUEUE</code> 
struct fields are overloaded using <code>#defines</code>:
</p>

<pre>
/* Effectively make a union out of the xQUEUE structure. */
#define pxMutexHolder         pcTail
#define uxQueueType           pcHead
#define uxRecursiveCallCount  pcReadFrom
#define queueQUEUE_IS_MUTEX   NULL
</pre>

<p>
EDIT: "For the most part FreeRTOS uses the same queue code to handle semaphores and mutexes."  I was still confused after reading this section, and when I see "for the most part", what I hear is an opportunity to explain architecture: the differences (and why they exist) are probably as interesting as the base mechanism.
</p>

<p>
For the most part FreeRTOS uses the same queue code to handle semaphores and 
mutexes.
</p>

<p>
The difference is that mutexes implement priority inheritance, whereas semaphores 
don't.
</p>

<p>
In case you're not familiar with priority inheritance, I'll quote Michael Barr 
again to define it, this time from his article, "Introduction to Priority 
Inversion":<sup class="footnote"><a href="#footnote-4">4</a></sup>
</p>


<p>
"[Priority inheritance] mandates that a lower-priority task inherit the priority 
of any higher-priority task pending on a resource they share. This priority change 
should take place as soon as the high-priority task begins to pend; it should end 
when the resource is released."
</p>

<p>
FreeRTOS implements priority inheritance using the <code>pxMutexHolder</code> 
field (which is really just the overloaded-by-<code>#define</code> 
<code>pcTail</code> field).  When a higher priority task is found to be waiting on a 
mutex currently taken by a lower priority task, FreeRTOS "upgrades" the lower 
priority task to the priority of the higher priority task until the mutex is 
available again.
</p>

</div>

</div>

</div>

<div class="sect">
<h2>999.4. Algorithms</h2>

<p>
EDIT: "Even though I paraphrased..." Please remove this sentence and find another opening.
</p>

<p>
Even though I paraphrased Fred Brooks as saying "Show me your data structures and 
I won't need your algorithms, they'll be obvious," it's still valuable to consider 
the algorithms FreeRTOS uses for tasks and queues.
</p>

<div class="subsect">
<h3>999.4.1. Task setup</h3>
    
<p>
A task is created when the user calls <code>xTaskCreate()</code>.
</p>

<p>
FreeRTOS uses a newly allocated TCB object to store the name, priority, and other 
details for a task.
</p>

<p>
FreeRTOS allocates the amount of stack the user requests (assuming there's enough 
memory available) and remembers the start of the stack memory in TCB's 
<code>pxStack</code> member.
</p>

<p>
The stack is initialized to look as if the new task is already running and was 
interrupted by a context switch. This way the scheduler can treat newly created tasks 
exactly the same way as tasks that have already been running for a while; the 
scheduler doesn't need any special case code for handling new tasks.
</p>

<p>
The exact way that a task's stack is made to look like it was interrupted by a 
context switch depends on the architecture FreeRTOS is running on, but this ARM 
Cortex-M3 processor's implementation is a good example:
</p>

<pre>
unsigned int *pxPortInitialiseStack( unsigned int *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
  /* Simulate the stack frame as it would be created by a context switch interrupt. */
  pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
  *pxTopOfStack = portINITIAL_XPSR;  /* xPSR */
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) pxCode;  /* PC */
  pxTopOfStack--;
  *pxTopOfStack = 0;  /* LR */
  pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
  *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;  /* R0 */
  pxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */
  
  return pxTopOfStack;
}
</pre>

<p>
After the stack is prepared, the task is almost ready to run.
</p>

<p>
First though, FreeRTOS disables interrupts: We're about to start mucking with the 
ready lists and other scheduler structures and we don't want anyone else changing 
them underneath us.
</p>

<p>
If this is the first task to ever be created, FreeRTOS initializes the scheduler's 
task lists. FreeRTOS's scheduler has an array of ready lists, 
<code>pxReadyTasksLists[]</code>, which has one ready list for each possible priority 
level. FreeRTOS also has a few other lists for tracking tasks that have been 
suspended, killed, and delayed. These are all initialized now as well.
</p>

<p>
After any first-time initialization is done the new task is added to the ready 
list at its specified priority level.
</p>

<p>
Interrupts are reenabled and new task creation is complete.
</p>

</div>

<div class="subsect">
<h3>999.4.2. Scheduler and the System Tick</h3>

<p>
The heartbeat of a FreeRTOS system is called the tick. FreeRTOS configures the 
system to generate a periodic tick interrupt. The user can configure the tick 
interrupt frequency, which is typically in the millisecond range.
</p>

<p>
EDIT: "Eery time the tick interrupt fires..."  Good --- this is the heart of the architecture, so as I said above, it should go near the top, and be the pivot around which other explanations revolve.
</p>

<p>
Every time the tick interrupt fires the <code>vTaskSwitchContext()</code> function 
is called. <code>vTaskSwitchContext()</code> makes sure the highest priority task is 
running like this:
</p>

<pre>
/* Find the highest priority queue that contains ready tasks. */
while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
{
    configASSERT( uxTopReadyPriority );
    --uxTopReadyPriority;
}

/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the same priority get an equal share of the processor time. */
listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
</pre>

<p>
It's as easy as a quick list traversal to find the highest priority level with 
ready tasks, and then grabbing the first ready task from that priority level's ready 
list.
</p>

<p>
Now <code>pxCurrentTCB</code> points to the highest priority task, and when 
<code>vTaskSwitchContext()</code> returns the processor dependent code starts running 
that task.
</p>

<p>
Those nine lines of code are the absolute crux of FreeRTOS. The rest of FreeRTOS 
(the other ~8991 lines) is there to make sure those nine lines are all that's needed 
to keep the highest priority task running.
</p>

</div>

<div class="subsect">
<h3>999.4.3. Queue Accesses</h3>

<p>
Since FreeRTOS uses queues as often as graphic designers use Apple comparisons, let's 
take a look at the queuing algorithms.
</p>

<p>
The queue insertion and removal algorithms are very similar, and so I'm only going 
to describe queue insertion as implemented in <code>xQueueGenericSend()</code>.  
Please check out the removal implementation in queue.c if you'd like to know how it's 
implemented.
</p>

<p>
Let's start by looking at a task, which I'll creatively call "Task A," inserting a 
new element into a queue. FreeRTOS uses the word "send" for inserting an item into a 
queue and "receive" for removing an item from a queue, but we'll use the more 
commonly used "insert" and "remove" here. (Using "send" and "receive" does make sense 
for FreeRTOS because it emphasizes that FreeRTOS uses queues for communication
between tasks.)
</p>

<p>
A word of warning: If the goto statement is considered harmful in code, then it 
must be considered downright evil in prose, but I'm going to use it anyway.
</p>

<p>
EDIT: "The queue insert function is basically..." this para and the two that follow say important things, but are awkwardly phrased.
</p>

<p>
The queue insert function is basically a big infinite <code>for()</code> loop that 
keeps looping until the queue insert succeeds or times out.
</p>

<p>
Later in this discussion I'm going to say that the queue code executes a "goto 
top".  That "goto" jumps here in the prose.
</p>

<p>
EDIT: "...you're hosed."  Again, too colloquial.
</p>

<p>
The first thing FreeRTOS does when accessing a queue is disables (most) 
interrupts, which causes context switches to also be disabled. If it didn't, another 
task or interrupt service routine could be switched in while Task A was in the middle 
of updating the queue's data structure, which could cause inconsistent data to be 
written.
</p>

<p>
Next FreeRTOS checks if the queue has space for the new element. 
</p>

<p>
EDIT: Section 999.4.3.1 and 999.4.3.2 --- please lose the subsubsection headings.  Also, will this be clearer with a decision tree diagram or flowchart accompanying the text?
</p>

<div class="subsubsect">
<h4>999.4.3.1. If the queue has room for a new element:</h4>

<p>
Then the new element is deep-copied into the queue and the queue size is updated.
Now FreeRTOS checks for any tasks waiting for data to arrive in the queue using the 
<code>xTasksWaitingToReceive</code> list.
</p>

<p>
If no task is waiting on data then FreeRTOS reenables interrupts and returns.  
Queue insertion is done.
</p>

<p>
If any tasks are waiting on data in the queue then FreeRTOS grabs the highest 
priority task from <code>xTasksWaitingToReceive</code>. We'll call it "Task B." If 
the currently running Task A is higher priority than Task B then FreeRTOS reenables 
interrupts and returns. Queue insertion is done.
</p>

<p>
If Task B is a higher priority than currently running Task A then Task A yields so 
that Task B is scheduled next. FreeRTOS reenables interrupts and returns. Queue 
insertion is done.
</p>

</div>

<div class="subsubsect">
<h4>999.4.3.2. If the queue is full and does not have room for a new element:</h4>

<p>
If Task A specified non-blocking queue insertion then we reenable interrupts and 
return. Queue insertion is done: the queue insertion failed.
</p>

<p>
If Task A specified blocking queue insertion then things get more interesting.
</p>

<p>
Let's review: if we "get here" in the algorithm the queue is full and Task A wants 
a blocking insertion.
</p>

<p>
Let's continue: FreeRTOS reenables interrupts but immediately disables the 
scheduler.  Now ISRs can fire so high priority real-time events can be handled, but 
no task switching can happen. The queue is now locked, which sets the 
<code>xRxLock</code> and <code>xTxLock</code> fields.
</p>

<p>
If the blocking timeout has expired then we unlock this queue, reenable the 
scheduler, then we "goto top." (Again, the code doesn't actually use a goto 
statement, it uses a for loop, but hey, this is prose, not code.)
</p>

<p>
If the blocking timeout hasn't expired then we check if the queue is still full.  
If it is still full, then we put Task A on the <code>xTasksWaitingToSend</code> list 
for this queue, unlock the queue, reenable the scheduler, and "goto top."
</p>

<p>
If the queue isn't full then we unlock the queue, reenable the scheduler, and
"goto top."
</p>

</div>


<p>
Note that Task A stays in <code>xQueueGenericSend()</code>'s infinite 
<code>for()</code> loop until the insert succeeds or the timeout expires. Other tasks 
may run during times when <code>xQueueGenericSend()</code> has left interrupts and 
task switching enabled.
</p>

</div>

</div>

<div class="sect">
<h2>999.5. Conclusion</h2>

<p>
We've completed our look at the FreeRTOS's main data structures and algorithms.
</p>

<p>
Hopefully you have a good feel for how FreeRTOS tasks run and communicate. And if 
you've never looked at any OS's internals before you now have a basic idea of how 
they work.
</p>

<p>
Obviously this chapter did not cover all of FreeRTOS's architecture. Notably, I 
didn't mention memory allocation, ISRs, debugging, or MPU support. Please check out 
the source code for more information about the FreeRTOS architecture.
</p>

<p>
This chapter also did not discuss how to setup or use FreeRTOS. Richard Barry has 
written an excellent book<sup class="footnote"><a href="#footnote-5">5</a></sup>, 
"Using the FreeRTOS Real Time Kernel - a Practical Guide," which discusses exactly 
that.  It's not free, but it's authoritative and very well written; I highly 
recommend it if you're going to use FreeRTOS.
</p>

<p>
[Amy/Greg: I'm not sure if I should use a footnote or a bibliography reference there: 
it's a book *and* a URL.]
</p>

</div>

<div class="sect">
<h2>999.6. Acknowledgements</h2>

<p>
I would like to thank Richard Barry for creating and maintaining FreeRTOS, and for 
choosing to make it open source. Richard was very helpful in writing this chapter, 
providing some FreeRTOS history as well as technical review.
</p>

<p>
Thanks also to Amy Brown and Greg Wilson for pulling this whole AOSA thing
together.
</p>

<p>
Last and most (the opposite of "not least"), thanks to my wife Sarah for
sharing me with the research and writing for this chapter. Luckily she knew I
was a geek when she married me!
</p>

</div>

<div class="footnotes">
<h2>Footnotes</h2>
<ol>
<li id="footnote-1"<code class="url">http://www.freertos.org</code</li>
<li id="footnote-2"<code class="url">http://www.wittenstein-us.com/Embedded-RTOS.html</code></li>
<li id="footnote-3"<code class="url">http://www.netrino.com/node/202</code></li>
<li id="footnote-4"<code class="url">http://www.eetimes.com/discussion/beginner-s-corner/4023947/Introduction-to-Priority-Inversion</code></li>
<li id="footnote-5"<code class="url">http://www.freertos.org/Documentation/FreeRTOS-documentation-and-book.html</code</li>
</ol>
</div>

<div class="footer">

</div>

  </body>
</html>
<!-- 
# vim: tw=85
# vim: formatoptions=tqaw
# vim: nosmartindent
-->
