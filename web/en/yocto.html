<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>The Architecture of Open Source Applications, Volume 2: Yocto</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.2  (Linux)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGED" CONTENT="20111206;21484400">
	<META NAME="provenance" CONTENT="$Id$">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<META NAME="CHANGEDBY" CONTENT="Elizabeth Flanagan">
	<STYLE TYPE="text/css">
	<!--
		H2.ctl { font-family: "Lohit Hindi" }
		PRE.cjk { font-family: "DejaVu Sans", monospace }
		CODE.cjk { font-family: "DejaVu Sans", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<TABLE CELLPADDING=2 CELLSPACING=2 STYLE="page-break-before: always">
	<TR>
		<TD STYLE="; border: none; padding: 0in">
			<P><FONT COLOR="#000080"><A HREF="index.html"><FONT COLOR="#000080"><IMG SRC="../images/titlebar.jpg" NAME="graphics1" ALIGN=BOTTOM WIDTH=426 HEIGHT=99 BORDER=1></FONT></A></FONT>
						</P>
		</TD>
		<TD STYLE="border: none; padding: 0in">
			<P STYLE="border: none; padding: 0in"><STRONG><EM>The Architecture
			of Open Source Applications, Volume 2</EM></STRONG> <STRONG>Amy
			Brown and Greg Wilson (eds.)</STRONG> 
			</P>
		</TD>
	</TR>
</TABLE>
<H1>Architecture of the Poky Build System</H1>
<H1><A HREF="intro.html#flanagan-elizabeth">Elizabeth Flanagan</A></H1>
<P><!-- Headers are level 2 with the following format:
<h2>{Chapter#}.{Section#} {Section Title}</h2>
--><!-- Then mostly normal markup for paragraphs
<p>Lorem Ipsum...</p>
--><!-- Example of how to incorporate a diagram
<div class="figure" id="fig.ffreleng.arch">
  <img src="../images/ffreleng/diagram.png" alt="[Image Title]" />
  <p>Figure&nbsp;{Chapter#}.{Section#}: {Image Title}</p>
</div>
--><!-- Introduction does not need a section div -->The
Yocto Project™ is an open source collaborative project that
provides a common starting point for developers of embedded Linux
systems to create customized distributions for embedded products in a
hardware agnostic setting. Sponsored by the Linux Foundation™,
Yocto is more than a build system. It provides tools, processes,
templates and methods for developers to rapidly create and deploy
products for the embedded market. One of the core components of
Yocto, is the Poky Build system. As Poky is a large and complex
system, we will be focusing on one of it's core components, bitbake.
Bitbake is a Gentoo Portage inspired build tool, used by both the
Yocto Project and OpenEmbedded communities to utilize metadata in
order to create Linux images from source.</P>
<H2 CLASS="western">1.0 Introduction and History</H2>
<P STYLE="margin-bottom: 0in">In 2001, Sharp Corporation introduced
the SL-5000 PDA, named Zaurus. It ran the embedded Linux
distribution, Embedix Plus, created by Caldera Systems (known by most
developers as Lineo).. Not long after the Zaurus's introduction,
Chris Larson founded the OpenZaurus Project, as a replacement Linux
distribution for the SharpROM, based on a build system called
buildroot.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">With the founding of the project,
people began contributing many more software packages, as well as
targets for other devices, and it wasn't long that the build system
for OpenZaurus began to show fragility. In January 2003, the
community began discussing a new build system to incorporate the
community usage model of a generic build system for embedded Linux
distributions. This would eventually become OpenEmbedded. Chris
Larson, Michael Lauer, and Holger Schurig began work on OpenEmbedded
by porting hundreds of OpenZaurus packages over to the new build
system.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The Yocto Project springs from this
work. At the project's core is the Poky build system, which began as
a branch of OpenEmbedded. Richard Purdie, the Yocto Project's lead
architect and a Linux Foundation Fellow, during his work at
OpenedHand Ltd, required a starting off point for OpenedHand's
embedded Linux efforts and decided to maintain a stabilized branch of
OpenEmbedded using a core subset of the thousands of OpenEmbedded
recipes, across a limited set of architectures. OpenedHand Ltd. was
acquired by Intel along with Poky and various pieces of related
technology.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">Over time, with the addition of more
and more functionality to and around Poky, it slowly coalesced into
more than just an embedded build system, but into a complete software
development platform, with Anjunta and Eclipse plugins, a fakeroot
replacement, profiling tools, and automated runtime image testing, as
well as QEMU based images. Around November 2010, the Linux Foundation
announced that this work would all continue under the heading of the
Yocto Project as a Linux Foundation sponsored project.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">It was then established that Yocto and
OpenEmbedded would work together and coordinate on a core set of
package metadata called OECore combining the best of both Poky and
OpenEmbedded with an increased use of layering for additional
components. 
</P>
<H2 CLASS="western">1.1 Overview of the Poky Build System</H2>
<P STYLE="margin-bottom: 0in"><SPAN STYLE="font-weight: normal"><BR>The
Poky build system is the core of the Yocto Project. In Poky's</SPAN>
<SPAN STYLE="font-weight: normal">default configuration, it can
provide a starting image footprint that ranges from a shell
accessible minimal image all the way up to a Linux </SPAN>Standard
Base compliant image with a GNOME Mobile and Embedded (GMAE) based
reference user interface called Sato. From these base image types,
metadata layers can be added to extend functionality; Layers can
provide an additional software stack for an image type, add a board
support package (BSP) for additional hardware or even represent a new
image type.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">In order to understand some of the more
complex issues the Yocto community has encountered, and how they
developed solutions to them, it is important to have a very generic
understanding of the Poky build process. Using the 1.1 release of
Poky, named “edison” (available at
<A HREF="http://downloads.yoctoproject.org/releases/yocto/yocto-1.1/poky-edison-6.0.tar.bz2">http://downloads.yoctoproject.org/releases/yocto/yocto-1.1/poky-edison-6.0.tar.bz2</A>
) we will step through what occurs behind the scenes during the
creation of a custom Linux image.</P>
<P STYLE="margin-bottom: 0in"><IMG SRC="../images/yocto/aosa1.jpg" NAME="graphics7" ALIGN=LEFT WIDTH=454 HEIGHT=588 BORDER=0><BR CLEAR=LEFT><I>Figure&nbsp;1.0:
Poky build process</I></P>
<P STYLE="margin-bottom: 0in"><BR>The first step to the build process
is setting up the shell environment for the build run. This is done
by sourcing a file, oe-init-build-env, that exists in the root of the
poky source tree. This sets up the shell environment, creates an
initial customizable set of configuration files and wraps the bitbake
runtime with a shell script that Poky uses to determine if the
minimal system requirements have been met. For example, one of the
things it will look for is the existence of Pseudo, a fakeroot
replacement contributed to the Yocto Project by Wind River Systems.
At this point, 'bitbake core-image-minimal', for example, should be
able to create a fully functional cross compilation environment and
then create a Linux image based on the image definition for
&quot;core-image-minimal&quot; from source as defined in the yocto
metadata layer.</P>
<P STYLE="margin-bottom: 0in"><BR>During the creation of our image,
bitbake will parse it's configuration, include any additional layers,
classes, tasks or recipes defined and begin by creating a weighted
dependency chain and a task execution queue. This process provides an
ordered and weighted task priority map. Bitbake uses this map to
determine what packages must be built in which order in order to most
efficiently fulfill compilation dependencies. Tasks needed by the
most other tasks are weighted higher and thus, run earlier during the
build process. Bitbake then stores the parsed metadata summaries and
if on subsequent runs, it determines that the metadata has changed,
it can re-parse only what has changed. The bitbake scheduler and
parser are some of the more interesting architectural designs of
bitbake and some of the decisions surrounding them and their
implementation by bitbake contributors are ones we will be discussing
later.<BR><BR>From a high level view, bitbake then runs through it's
weighted task queue, spawning threads (up to the number defined by
BB_NUMBER_THREADS in conf/local.conf) that begin executing those
tasks in the predetermined order. The tasks executed during a
package's build out may be modified, prepended or appended to through
it's recipe. The basic, default package task order of execution
starts by fetching and unpacking package source and then configuring
and cross-compiling the unpacked source. The compiled source is then
split up into packages and various calculations are made on the
compilation result (such as the creation of debug package
information). The split up packages are then packaged into a
supported package format; rpm, ipk or deb package formats being
supported. Bitbake will then begin to use these packages to build the
root file system.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H2 CLASS="western">1.2 The Poky Build System</H2>
<P>One of the most powerful aspects of the Poky build system is that
every aspect of a build is controlled by metadata. Metadata can be
loosely grouped into configuration files or package recipes.
Furthermore we can break configuration files down into two types.
That which configures bitbake and the overall build run and that
which configures the various layers we use to create different
configurations of our target image.</P>
<H2 CLASS="western">1.2.1 Bitbake Layers</H2>
<P>One concept that the Poky build system uses is that of layers. A
layer is any grouping of metadata that provides some sort of
additional functionality. These can be anything from BSP enablement
to adding an additional image type or including additional software.
In fact, the core Yocto metadata, meta-yocto, is itself a layer
applied on top of the OECore metadata layer, meta. 
</P>
<P>When working with Poky builds, it is advisable that we split
functionality into layers. For example, let's say we wanted to create
a NAS device for the Intel n660 (Crownbay). We wanted our device to
use x32, the new 32-bit native ABI for x86-64, in order to lower our
memory footprint. We also want our device to have some custom
software added to it, for example, a user interface. Given the task
at hand, we want to split this functionality out into layers; a BSP
layer for Crownbay, a layer to enable x32, the Yocto Project's
example NAS layer, called meta-baryon and a user interface layer of
our own, which we will call meta-myproject.</P>
<P STYLE="margin-bottom: 0in"><IMG SRC="../images/yocto/aosa2.jpg" NAME="graphics2" ALIGN=LEFT WIDTH=559 HEIGHT=314 BORDER=0><BR CLEAR=LEFT><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT SIZE=3><I>Figure&nbsp;2.0:
Example of Bitbake layering</I></FONT></P>
<P><BR><BR>
</P>
<P>During the setup of the bitbake environment, by sourcing
oe-build-init-env, some initial configuration files were generated.
These configuration files allow us quite a bit of control over how
and what Poky generates. The first of these configuration files is
bblayers.conf. This file is what we will use to add additional layers
in order to build our example project.</P>
<P><FONT FACE="Courier 10 Pitch"><FONT SIZE=3># LAYER_CONF_VERSION is
increased each time build/conf/bblayers.conf <BR># changes
incompatibly <BR>LCONF_VERSION = &quot;4&quot; <BR>BBFILES ?= &quot;&quot;
<BR>BBLAYERS = &quot; \ <BR>/home/eflanagan/poky/meta \
<BR>/home/eflanagan/poky/meta-yocto \
<BR>/home/eflanagan/poky/meta-intel/crownbay \
<BR>/home/eflanagan/poky/meta-x32 \<BR>/home/eflanagan/poky/meta-baryon
\ <BR>/home/eflanagan/poky/meta-myproject \ <BR>&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in"><I>Figure&nbsp;3.0: example
bblayers.conf</I></P>
<P><BR>The bitbake layers file, bblayers, defines a variable,
BBLAYERS that bitbake uses to look for bitbake layers. In order to
fully understand this, we should also look at how our layers are
actually constructed. Using meta-baryon (from
<A HREF="git://git.yoctoproject.org/meta-baryon">git://git.yoctoproject.org/meta-baryon</A>)
as our example layer, we want to examine the layer configuration
file. This file, conf/layer.conf, is what bitbake parses after it's
initial parsing of bblayers.conf. From here it adds additional
recipes, classes and configuration to the build.</P>
<PRE CLASS="western"><CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3># Layer configuration for meta-baryon layer</FONT></FONT></CODE>
<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3># Copyright 2011 Intel Corporation</FONT></FONT></CODE>
<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3># We have a conf directory, prepend to BBPATH to prefer our versions</FONT></FONT></CODE>
<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BBPATH := &quot;${LAYERDIR}:${BBPATH}&quot;</FONT></FONT></CODE>

<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3># We have recipes-* directories, add to BBFILES</FONT></FONT></CODE>
<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BBFILES := &quot;${BBFILES} ${LAYERDIR}/recipes-*/*/*.bb ${LAYERDIR}/recipes-*/*/*.bbappend&quot;</FONT></FONT></CODE>

<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BBFILE_COLLECTIONS += &quot;meta-baryon&quot;</FONT></FONT></CODE>
<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BBFILE_PATTERN_meta-baryon := &quot;^${LAYERDIR}/&quot;</FONT></FONT></CODE>
<CODE CLASS="western"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BBFILE_PRIORITY_meta-baryon = &quot;7&quot;</FONT></FONT></CODE></PRE><P STYLE="margin-bottom: 0in">
<I>Figure&nbsp;4.0: meta-baryon's layer.conf</I></P>
<P><BR><BR>
</P>
<P>Examining this file, line by line, we can see that we've define
five variables. The first, BBPATH, is a PATH-like variable used by
bitbake that prepends the path of the layer to itself using the
layers LAYERDIR variable. Notice, however, that we've defined BBPATH
using the ':=' operator. This results in BBPATH's contents being
expanded immediately, rather than when we use the variable as would
occur during lazy expansion. The next line, defines BBFILES. This
variable defines the list of recipe files (*.bb and *.bbappend)
within this layer and is appended to any prior definitions of BBFILE
by the addition of ${BBFILES} to the variable. 
</P>
<P>Next, we define BBFILE_COLLECTIONS, which is a collection of all
layer names. It uses the '+=' operator in order to denote that we are
appending the name of the layer “meta-baryon” to this global
variable. We also define the BBFILE_PATTERN for this layer. This
variable is again immediately expanded with a regexp. It is used to
match files from BBFILES into a particular layer, in this case by
using the base pathname LAYERDIR. Lastly, we define the priority of
the layer. This is useful as our layer may contain packages that
another layer may also contain. The use of BBFILE_PRIORITY helps
bitbake determine which layer's packages has precedence over the
other.</P>
<H2 CLASS="western">1.2.2 Configuration Files</H2>
<P>During the beginning of a build, bitbake's BBCooker class is
started. The cooker, which we will discuss later, manages the build
run by 'baking' the 'recipes'. One of the first things the cooker
does, is attempt to load and parse configuration data. Remember,
though, that bitbake is looking for two types of configuration data. 
</P>
<P>In order to tell the build system where it should find that
configuration data and in turn where to find the rest of it's
metadata, the cooker's parseConfigurationFiles method is called. With
few exceptions, the first configuration files that the cooker looks
for is bblayers.conf and then it will add those layers to it's
BBLAYERS variable. It does this because the next file it attempts to
parse and load is the bitbake.conf file stored in meta/conf and the
includes it will try to import are relative to each layer in
BBLAYERS. Bitbake.conf is the main configuration file for bitbake and
sets up build time variables, such directory structure naming for
various rootfs directories; the initial LDFLAGS to be used during
compile time. Most end users will never touch this file as most
anything needed to be changed here would be within a recipe context
as opposed to build wide. One thing bitbake.conf does however, is it
also includes other configuration files, relative to each of the
layers indicated in BBLAYERS.</P>
<P><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>include conf/site.conf
<BR>include conf/auto.conf <BR>include conf/local.conf <BR>include
conf/build/${BUILD_SYS}.conf <BR>include
conf/target/${TARGET_SYS}.conf <BR>include
conf/machine/${MACHINE}.conf </FONT></FONT>
</P>
<P><FONT FACE="Courier 10 Pitch"><FONT SIZE=2><BR></FONT></FONT><FONT FACE="Liberation Serif, serif"><FONT SIZE=3><I>Figure
5.0 Portion of bitbake.conf showing included configuration files</I></FONT></FONT></P>
<P>Only one of these above included .conf files from bitbake.conf is
actually created during environment setup. That file, local.conf, is
used to set global bitbake variables. While any bitbake variable may
be set within any one of these configuration files that is included
from bitbake.conf, the Yocto Project and OpenEmbedded have taken it
as a best practice to use each of these includes for specific
purposes. For example, for host system specific settings, like proxy
settings, site.conf is utilized. Auto.conf is generally used as a
local.conf in autobuilder specific applications, specifically, the
yocto-autobuilder.</P>
<P><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BB_NUMBER_THREADS =
&quot;14&quot; <BR>PARALLEL_MAKE = &quot;-j 12&quot; <BR>MACHINE ??=
&quot;crownbay&quot; <BR>DL_DIR ?= &quot;/home/eflanagan/downloads&quot;
<BR>SSTATE_DIR ?= &quot;/home/eflanagan/sstate-cache&quot; <BR>TMPDIR
= &quot;${TOPDIR}/tmp&quot; <BR>DISTRO ?= &quot;poky&quot;
<BR>PACKAGE_CLASSES ?= &quot;package_rpm&quot; <BR>SDKMACHINE ?=
&quot;i686&quot; <BR>CONF_VERSION = &quot;1&quot; </FONT></FONT>
</P>
<P STYLE="font-weight: normal"><FONT FACE="Liberation Serif, serif"><FONT SIZE=3><I>Figure
6.0: Contents of an example local.conf file</I></FONT></FONT></P>
<P STYLE="margin-bottom: 0in"><SPAN STYLE="font-weight: normal">Now
that we </SPAN><SPAN STYLE="font-weight: normal">have an
understanding of</SPAN><SPAN STYLE="font-weight: normal"> layers and
have a general overview of how one can configure bitbake through it's
configuration files, we can look at how we define software packages.
All software built during a build execution is defined by it's
recipe. A recipe is a collection of</SPAN> <SPAN STYLE="font-weight: normal">non-executable
metadata used by bitbake to set variables or define additional build
time tasks. An example of this can be seen in the recipe for grep. </SPAN>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>DESCRIPTION
= &quot;GNU grep utility&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>HOMEPAGE
= &quot;http://savannah.gnu.org/projects/grep/&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>BUGTRACKER
= &quot;http://savannah.gnu.org/bugs/?group=grep&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>SECTION
= &quot;console/utils&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>LICENSE
= &quot;GPLv3&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>LIC_FILES_CHKSUM
= &quot;file://COPYING;md5=8006d9c814277c1bfc4ca22af94b59ee&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>PR
= &quot;r0&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>SRC_URI
= &quot;${GNU_MIRROR}/grep/grep-${PV}.tar.gz&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>SRC_URI[md5sum]
= &quot;03e3451a38b0d615cb113cbeaf252dc0&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>SRC_URI[sha256sum]
= &quot;e9118eac72ecc71191725a7566361ab7643edfd3364869a47b78dc934a357970&quot;
</FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>inherit
autotools gettext </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>EXTRA_OECONF
= &quot;--disable-perl-regexp&quot; </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>do_configure_prepend
() { </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>rm
-f ${S}/m4/init.m4 </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>}
</FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>do_install
() { </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>autotools_do_install
</FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>install
-d ${D}${base_bindir} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>mv
${D}${bindir}/grep ${D}${base_bindir}/grep.${PN} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>mv
${D}${bindir}/egrep ${D}${base_bindir}/egrep.${PN} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>mv
${D}${bindir}/fgrep ${D}${base_bindir}/fgrep.${PN} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>}
</FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>pkg_postinst_${PN}
() { </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>update-alternatives
--install ${base_bindir}/grep grep grep.${PN} 100 </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>update-alternatives
--install ${base_bindir}/egrep egrep egrep.${PN} 100 </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>update-alternatives
--install ${base_bindir}/fgrep fgrep fgrep.${PN} 100 </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>}
</FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>pkg_prerm_${PN}
() { </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>update-alternatives
--remove grep grep.${PN} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>update-alternatives
--remove egrep egrep.${PN} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>update-alternatives
--remove fgrep fgrep.${PN} </FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in; font-weight: normal"><FONT FACE="Courier 10 Pitch"><FONT SIZE=3>}
</FONT></FONT>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT FACE="Liberation Serif, serif"><FONT SIZE=3><I>Figure
7: Contents of the bitbake recipe for grep</I></FONT></FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><SPAN STYLE="font-weight: normal">In
this recipe, metadata, such as the </SPAN><SPAN STYLE="font-weight: normal">recipe</SPAN><SPAN STYLE="font-weight: normal">
description, </SPAN><SPAN STYLE="font-weight: normal">the recipe
version, the</SPAN><SPAN STYLE="font-weight: normal"> </SPAN><SPAN STYLE="font-weight: normal">license
of the package and the upstream source repository</SPAN><SPAN STYLE="font-weight: normal">
are se</SPAN><SPAN STYLE="font-weight: normal">t</SPAN><SPAN STYLE="font-weight: normal">.
</SPAN><SPAN STYLE="font-weight: normal">T</SPAN><SPAN STYLE="font-weight: normal">he
recipe </SPAN><SPAN STYLE="font-weight: normal">also</SPAN><SPAN STYLE="font-weight: normal">
indicates that the build process utilizes autoconf and automake, so
it inherits </SPAN><SPAN STYLE="font-weight: normal">Poky's</SPAN><SPAN STYLE="font-weight: normal">
autotools functionality as defined within the OE</SPAN><SPAN STYLE="font-weight: normal">-</SPAN><SPAN STYLE="font-weight: normal">Core
layer's autotools.bbclass. Additional tasks are</SPAN> <SPAN STYLE="font-weight: normal">then
defined, such as one that executes update-alternatives to set the
default grep to this package</SPAN><SPAN STYLE="font-weight: normal">'</SPAN><SPAN STYLE="font-weight: normal">s
</SPAN><SPAN STYLE="font-weight: normal">contents </SPAN><SPAN STYLE="font-weight: normal">and
</SPAN><SPAN STYLE="font-weight: normal">to </SPAN><SPAN STYLE="font-weight: normal">remove
any existing grep, such as busybox's grep. With </SPAN><SPAN STYLE="font-weight: normal">the
recipe above</SPAN><SPAN STYLE="font-weight: normal">,</SPAN> <SPAN STYLE="font-weight: normal">we've
prepended extra script functionality to the do_configure</SPAN> <SPAN STYLE="font-weight: normal">task
by adding</SPAN> <SPAN STYLE="font-weight: normal">do_configure_prepend
to the recipe. Bitbake supports both _prepend and _append as a method
of</SPAN> <SPAN STYLE="font-weight: normal">extending</SPAN> <SPAN STYLE="font-weight: normal">task
functionality </SPAN><SPAN STYLE="font-weight: normal">by injecting
the prepend or append into the beginning or end of the task</SPAN><SPAN STYLE="font-weight: normal">.
You can also see that this recipe includes a task named do_install.
This task, </SPAN><SPAN STYLE="font-weight: normal">while it does run
the original autotools_do_install, this task is injected into the
base in order to move the grep binaries</SPAN><SPAN STYLE="font-weight: normal">.</SPAN></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The last two portions of this recipe
include the pkg_prerm_${PN} and pkg_postinst_${PN} functions, where
PN is the package name. These two functions act on the packages
created by this recipe. This injects the code contained within the
two functions into the appropriate places during the packaging up of
grep. In this case, whenever grep is packaged up, update-alternatives
is injected into the do_package function of each of the package
bbclasses for the three supported package formats; rpm, ipk, and deb.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H2 CLASS="western">1.3 Bitbake Architecture</H2>
<P>Before we delve into some of bitbake's current architectural
design, it would help to understand how bitbake once worked. For
this, in order to fully appreciate how far bitbake has come, we will
use the initial version, bitbake 1.0.</P>
<P>In bitbake 1.0, a build's dependency chain was determined based
upon recipe dependencies. If something failed during the build of an
image, bitbake would move on to the next task and try to run it again
later. What this means, obviously, is that builds took a very long
time. One of the things bitbake also did is keep each and every
variable that a recipe used in one very large dictionary. Given the
number of recipes and the number of variables and tasks needed to
accomplish a build, bitbake 1.0 was a memory hog. At a time when
memory was expensive and systems did not have much, builds could be
painful affairs. It was not unheard of for a system to run out of
memory (writing to swap!) as it slugged through a long running build.
In it's first incarnation, while it did the job (sometimes), it did
it slowly while consuming enormous resources. Worse, as bitbake 1.0
had no concept of a data persistence cache or shared state, it also
had no ability to do incremental builds. So if a build failed, one
would have to restart it from scratch. 
</P>
<P>A quick diff between the current bitbake version used in Poky
“edison” 1.13.3 and 1.0 shows the implementation of bitbake's
client-server architecture, the data persistence cache, it's
datastore, a copy-on-write improvement for the datastore, shared
state implementation and drastic improvements over how it determines
task and package dependency chains. This evolution has made it more
reliable, more efficient and more dynamic. Much of this functionality
came out of necessity for quicker more reliable builds that used less
resources. Three improvements to bitbake that we will examine is the
implementation of a client-server architecture, optimizations around
bitbake's data storage and work done around how bitbake determines
it's build and task dependency chain. 
</P>
<H2 CLASS="western">1.3.1 Bitbake IPC</H2>
<P STYLE="margin-bottom: 0in">Since we now know a good deal about how
the Poky build system utilizes configurations, recipes and layers to
create embedded images, we're prepared to begin to look under the
hood of bitbake and examine how this is all combined. Starting with
the core bitbake executable, bitbake/bin/bitbake, we can begin to see
the process bitbake takes as it begins to set up the infrastructure
needed to begin a build. The first item of interest is bitbake's
Interprocess Communications (IPC). Initially, bitbake had no actual
concept of a client-server. This functionality was factored into the
bitbake design over a period of time in order to allow bitbake to run
multiple processes during a build, as it was initially single
threaded, and to allow different user experiences.</P>
<P STYLE="margin-bottom: 0in"><IMG SRC="../images/yocto/aosa3.jpg" NAME="graphics3" ALIGN=LEFT WIDTH=480 HEIGHT=480 BORDER=0><BR CLEAR=LEFT><BR>
</P>
<P STYLE="margin-bottom: 0in"><FONT FACE="Liberation Serif, serif"><FONT SIZE=3><I>Figure
8: Overview of bitbake IPC</I></FONT></FONT></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">All Poky builds are begun by starting a
user interface instance. The user interface provides a mechanism for
logging of build output, build status and build progress as well as
receiving events from build tasks through the bitbake event module.
The default user interface used is knotty, bitbake's command line
interface. Called knotty, or “(no) tty”, since it handles both
ttys and non-ttys, it is one of a few interfaces that are supported.
One of these additional user interfaces is Hob. Hob is the graphical
interface to bitbake, a kind of “bitbake commander”. In addition
to the typical functions you would see in the knotty user interface,
hob, written by Joshua Lock, brings the ability to modify
configuration files, add additional layers and packages, and fully
customize a build.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">Bitbake user interfaces have the
ability to send commands to the next module brought up by the bitbake
executable, the bitbake server. Like the user interface, bitbake also
supports multiple different server types, amongst them XMLRPC. The
default server that most users use when executing bitbake from the
knotty user interface is bitbake's process server. After bringing up
the server, the bitbake executable brings up the cooker. 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The cooker is a core portion of bitbake
and is where most of the particularly interesting things that occur
during a Poky build are called from. The cooker is what manages the
parsing of metadata, initiates the generation of the dependency and
task trees, and manages the build. One of the functions of bitbake's
server architecture is allowing multiple ways of exposing the command
API, indirectly, to the user interface. The command module is the
worker of bitbake, running build command and triggering events that
get passed up to the user interface through bitbakes event handler.
Once the cooker is brought up from the bitbake executable, it
initializes the bitbake datastore and then begins to parse all of
Poky's configuration files. It then creates the runqueue object, and
triggers off the build. 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H2 CLASS="western">1.3.2 Bitbake DataSmart copy-on-write data
storage</H2>
<P>In bitbake 1.0, all bitbake variables were parsed and stored in
one very large dictionary during the initialization of that version's
data class. As previously mentioned, this was problematic, in that
very large python dictionaries are slow on writes and member access
and if the build host runs out of physical memory during the build,
we end up hitting swap. While this is less likely in most systems in
late 2011, when OpenEmbedded and bitbake were first starting up, the
average computer's specification did not generally have more than one
or two gigabytes of memory, and usually, quite less.</P>
<P>This was one of the major pain points in early bitbake. Two major
issues needed to be worked out in order to help increase performance.
One was precomputation of the build dependency chain. The other was
to reduce the size of data being stored in memory. As much of the
data being stored for a recipe doesn't change from recipe to recipe,
for example, TMPDIR, BB_NUMBER_THREADS and other global bitbake
variables, having a copy of the entire data environment per recipe
stored in memory was inefficient. The solution was Tom Ansell's
copy-on-write dictionary that “abuses classes to be nice and fast”.
Bitbake's COW module is both an especially fearless and clever hack.
Running 'python bitbake/lib/bb/COW.py' and examining the  module will
give you an idea of how this copy-on-write implementation works and
how bitbake uses it to store data efficiently</P>
<P>The DataSmart module, which utilizes the COW dictionary, stores
the data from the initial poky configuration, data from .conf files
and .bbclass files, in a dict as a data object. Each of these objects
can contain another data object of just the diff of the data. So if a
recipe changes something from the initial data configuration, instead
of copying the entire configuration in order to localize it, a diff
of the parent data object is stored at the next layer down in the in
the COW stack. When an attempt is made to access a variable, the data
module will use DataSmart to look into the top level of the stack. If
the variable is not found it will defer to a lower level of the stack
until it does find the variable or errors out.</P>
<P>One of the other interesting things about the DataSmart module
centers around variable expansion. As bitbake variables can contain
executable python, one of the things that needs to be done is the
variable needs to be run through bitbakes bb.codeparser to ensure
that it's valid python and that it contains no circular references.
An example of a variable containing python is this example taken from
./meta/conf/distro/include/tclibc-eglibc.inc</P>
<P STYLE="margin-bottom: 0in">LIBCEXTENSION = &quot;${@['',
'-gnu'][(d.getVar('ABIEXTENSION', True) or '') != '']}&quot;</P>
<P></P>
<P>This variable is included from one of the OE-Core configuration
files, ./meta/conf/distro/include/defaultsetup.conf and is used to
provide a set of default options across different distro
configurations that one would want to lay on top of Poky or
OpenEmbedded. This file imports some eglibc specific variables that
are set dependent on the value of another bitbake variable
ABIEXTENSION. During the creation of the datastore, the python within
this variable needs to be parsed and validated to ensure tasks that
utilize this variable will not fail.</P>
<H2 CLASS="western">1.3.3 Bitbake Scheduler</H2>
<P>Once bitbake has parsed the configuration and created it's
datastore, it needs to parse the recipes required for the image and
produce a build chain. This is one of the more substantial
improvements to bitbake. Originally, bitbake took it's build
priorities from a recipe. If a recipe had a DEPENDS, it would try to
figure out what to build in order to satisfy that dependency. If a
task failed because it lacked a prerequisite needed for it's
buildout, it was simply put to the side and attempted later. This had
obvious drawbacks, both in efficiency and reliability.</P>
<P>As no precomputed dependency chain was established, task execution
order was figured out during the build run. This limited bitbake to
being single threaded as at no time. To give an idea of how painful
single threaded bitbake builds can be, the smallest image
“core-image-minimal” on a standard developer machine in 2011
(<EM><SPAN STYLE="font-style: normal">Core</SPAN></EM><SPAN STYLE="font-style: normal">™
</SPAN><EM><SPAN STYLE="font-style: normal">i7, 16 gigabytes of DDR3
memory) takes about  three or four hours to build a complete cross
compilation toolchain and use it to produce packages that are then
used to create an image. For reference, a build on the same machine
with BB_NUMBER_THREADS at 14 and PARALLEL_MAKE set to “-j 12”
takes about 30 to 40 minutes. As one could imagine running single
threaded with no precomputed order of task execution on slower
hardware that had less memory with a large portion wasted by
duplicate copies of the entire datastore took much longer.</SPAN></EM></P>
<H2 CLASS="western">1.3.3.1 Dependencies</H2>
<P>When we talk of build dependencies, we need to make a distinction
between the various types. A build dependency, or DEPENDS, is
something we require as a prerequisite so that Poky can build the
required package, whereas a runtime dependency, RDEPENDS, requires
that the image the package is to be installed on also contain the
package listed as an RDEPENDS. Take, for example, the package
task-core-boot. If we look at the recipe for it in
meta/recipes-core/tasks/task-core-boot.bb we will see two bitbake
variables set. RDEPENDS and DEPENDS. Bitbake uses these two fields
during the creation of it's dependency chain. 
</P>
<P><FONT FACE="Courier 10 Pitch">DEPENDS = &quot;virtual/kernel&quot;
<BR>...</FONT></P>
<P><FONT FACE="Courier 10 Pitch">RDEPENDS_task-core-boot = &quot;\
<BR>base-files \ <BR>base-passwd \ <BR>busybox \ <BR>initscripts \ </FONT>
</P>
<P><FONT FACE="Courier 10 Pitch">...</FONT></P>
<P><I>Figure 10: Portion of task-core-boot.bb showing DEPENDS and
RDEPENDS</I></P>
<P STYLE="font-style: normal">Packages aren't the only thing in
bitbake with dependencies. Tasks also have their own dependencies.
Within the scope of bitbake's runqueue, we recognize four types:
Interally dependent, DEPENDS dependent, RDEPENDS dependent and
inter-task dependent.</P>
<P STYLE="font-style: normal">Internally dependent tasks are set
within a recipe and add a task before and/or after another task. For
example, in a recipe, we could add a task called “do_deploy” by
adding the line 'addtask deploy before do_build after do_compile'.
This would add a dependency for running the do_deploy task prior to
do_build being started, but after do_compile is completed. DEPENDS
and RDEPENDS dependent tasks are tasks that run after a denoted task.
For example, if we wanted to run do_deploy of a package after the
do_install of it's DEPENDS or RDEPENDS, our recipe would include
“do_deploy[deptask] = 'do_install' “ or “do_deploy[rdeptask] =
'do_install' “. For inter-task dependencies, if we wanted a taks to
be dependant on a different package's task we would add, using the
above example of do_deploy, do_deploy[depends] = “&lt;target's
name&gt;:do_install”. 
</P>
<H2 CLASS="western">1.3.3.2 RunQueue</H2>
<P><SPAN STYLE="font-style: normal">As an image build out can have
hundreds of recipes, each with multiple packages and task, each of
with it's own dependency, bitbake is now tasked with trying to sort
this out into something it can use as an order of execution. A</SPAN>fter
the cooker has gotten the entire list of packages needed to be built
from the initialization of the bb.data object, it will begin to
create a weighted task map from this data in ordered to produce an
ordered list of tasks it needs to run, called the runqueue. Once the
runqueue is created, bitbake can begin executing it in priority
order, tasking out each portion to a different thread.</P>
<P>Within the provider module, bitbake will first look to see if
there is a PREFERRED_PROVIDER for a given package or image. As more
than one recipe can provide a given package and as tasks are defined
in recipes, bitbake needs to decide which provider of a package it
will use. It will sort all the providers of the package, weighting
each provider by various criteria. For example, preferred versions of
software will get a higher priority than others, however, bitbake
also takes into account package version as well as the dependencies
of other packages. Once it has selected the recipe from which it will
derive it's package, bitbake will iterate over the DEPENDS and
RDEPENDS of that recipe and proceed to compute the providers for
those packages. This chain reaction will produce a list of packages
need to for image generation as well as providers for those packages.</P>
<P>Runqueue now has a full list of all packages needed to be built
and a dependency chain. In order to begin execution of the build, the
runqueue module now needs to create the TaskData object in order to
begin to sort out a weighted task map. It begins by taking each
buildable package it has found, spliting out the tasks needed to
generate that package and weighing each of those tasks based upon the
number of packages that require it. Tasks with a higher weight have
more dependants, and therefore are generally run earlier in the
build. Once this is complete, the runqueue module then prepares to
convert the TaskData object into a runqueue.</P>
<P>The creation of the runqueue is somewhat complex. Bitbake first
iterates through the list of task names within the TaskData object in
order to determine task dependencies. As it iterates through 
TaskData, it begins to build a weighted task map. When it is
complete, if it has found no circular dependencies, unbuildable tasks
or any such problems, it will then order the task map by weight and
return a complete runqueue object to the cooker. The cooker will
begin to attempt to execute the runqueue, task by task. At this
point, we've at last begun to build what will become an embedded
Linux image.</P>
</BODY>
</HTML>