\begin{aosachapter}{matplotlib}{s:matplotlib}{John Hunter and Michael Droettboom}




matplotlib is a Python plotting library widely used in the scientific
Python computing community with full support for 2D graphics and
limited support for 3D.  The library targets a broad range of use
cases.  It can embed graphics in the user interface toolkit of your
choice, and currently supports interactive graphics on all major
desktop operating systems in the GTK, Qt, Tk, FLTK, WX and Cocoa
toolkits.  In can be called interactively from the the interactive
python shell to produce graphics with simple, procedural commands much
like Mathematica (TM), IDL (TM) or Matlab (TM).  And it can be
embedded in a headless webserver to provide hardcopy in both raster
based formats like Portable Network Graphics (PNG) as well as vector
formats like Postscript, Portable Document Format (PDF) and Scalable
Vector Graphics (SVG).

\begin{aosasect1}{The Dongle Problem}

matplotlib's origin dates to an attempt by one of us (John Hunter) to
free himself and his fellow epilepsy researchers from a proprietary
software package for doing Electrocorticography (ECOG) analysis.  The
laboratory in which he worked had only one license to the software,
and the various graduate students, medical students, postdocs, interns
and investigators took turns sharing the hardware key dongle.  Matlab
(TM) is widely used in the biomedical community for data analysis and
visualization, so Hunter set out, with some success, to replace the
proprietary software with a Matlab based version that could be
utilized and extended by multiple investigators.  Matlab, however,
naturally views the world as an array of floating point numbers, and
the complexities of real-world hospital records for epilepsy surgery
patients with multiple data modalities (CT, MRI, ECOG, EEG) warehoused
on different servers pushed Matlab to its limits as a data management
system.  Unsatisfied with the suitability of Matlab for this task,
Hunter began anew on a Python application built on top of the user
interface toolkit GTK, at the time the leading desktop windowing
system for Linux.

matplotlib was thus originally developed as a EEG/ECOG visualization
tool for this GTK application, and this use case informed its original
architecture.  matplotlib was originally designed to serve a second
purpose as well: as a replacement for interactive command driven
graphics generation, something that Matlab does very well.  When you
just want to load a data file and plot a histogram, a full object
oriented API is usually a bit too syntactically heavy and does not
suit many bench scientists familiar with the commercial tools that
provide an easy scripting interface.  So matplotlib also provides a
stateful scripting interface for quick and easy generation graphics.
Since this is something Matlab \emph{does} do quite well, matplotlib
implements much of its scripting interface.

\aosafigure{../images/matplotlib/ecog.png}{The original matplotlib application: an ECOG viewer}{fig.matplotlib.ecog}[scale=0.2]
\end{aosasect1}

\begin{aosasect1}{Overview of matplotlib architecture}


The top level matplotlib object that contains and manages all of the
elements in a given graphic is called the Figure.  One of the core
architectural tasks matplotlib must solve is implementing a framework
for representing and manipulating the Figure must be segregated from
the act of rendering the Figure either to a user interface window or
hardcopy.  This enables us to build increasingly sophisticated
features and logic into the Figures, while keeping the "backends", or
output devices, relatively simple.  Because matplotlib encapsulates
not just the drawing interfaces to allow rendering to multiple
devices, but also the basic event handling and windowing of most
popular user interface toolkits, users can create fairly rich
interactive graphics and toolkits incorporating mouse and keyboard
input that can be plugged without modification into the six user
interface toolkits we support across the major desktop operating
systems.

The architecture to accomplish this is logically separated into three
layers, which can be viewed as a stack.  Each layer which sits above a
lower layer knows how to talk to the layer below it, but the lower
layer is not aware of the layers above it.  The three layers from
bottom to top are: backend, artist and scripting.

\begin{aosasect2}{Backend layer}

At the bottom of the stack is the \emph{backend}, which provide
concrete implementations of the abstract interface classes
FigureCanvas, the Renderer and Event, which encapsulate the concept of
a surface to draw onto (FigureCanvas, eg "the paper"), a device which
does the drawing (Renderer, eg "the paintbrush") and the handling of
user inputs such as keyboard and mouse events (Event).  For a user
interface toolkit such as Qt, the Canvas has a concrete implementation
which knows how to insert itself into a native Qt window
(QtGui.QMainWindow), knows how to transfer the matplotlib Renderer
commands onto the canvas (QtGui.QPainter), and knows how to translate
native Qt events into the matplotlib Event framework and signal the
callback dispatcher to generate the events so upstream listeners can
handle them.  The abstract base classes reside in
\code{matplotlib.backend\_bases} and all of the derived classes live in
dedicated modules like \code{matplotlib.backends.backend\_qt4agg}.  For
a pure image background dedicated to producing hardcopy output like
PDF, PNG, SVG, or PS, the FigureCanvas implementation might simply set
up a file-like object into which the default headers, fonts, and macro
functions are defined, as well as the individual objects (lines, text,
rectangles, etc) that the renderer creates.

The job of the Renderer is to provide a low-level drawing interface
for putting ink onto the canvas.  As mentioned above, the original
matplotlib application was an ECOG viewer in a GTK application, and
much of the original design was inspired by the GDK/GTK API available
at that time.  The original Renderer API was motivated by the GDK
Drawable interface, which implements such primitive methods as
\code{draw\_point}, \code{draw\_line}, \code{draw\_rectangle},
\code{draw\_image}, \code{draw\_polygon}, and \code{draw\_glyphs}.  Each
additional backend we implemented -- the earliest were the Postscript
backend and the GD backend -- implemented the GDK Drawable API and
translated these into native backend dependent drawing commands.  As
we discuss below, this unnecessarily complicated the implementation of
new backends with a large proliferation of methods, and this API has
subsequently been dramatically simplified, with the result that
porting matplotlib to a new user interface toolkit or file
specification is comparatively simple.

One of the design decisions that has worked quite well for matplotlib
is the support for a core pixel based renderer using the C++ template
library antigrain geometry (XXX CITE) or "agg".  This is a high
performance library for rendering anti-aliased 2D graphics which
produces attractive images.  matplotlib provides support for inserting
pixel buffers rendered by the agg backend into each user interface
toolkit we support, so one can get pixel exact graphics across UIs and
operating systems.  Because the PNG output matplotlib produces also
uses the agg renderer, the hardcopy is identical to the screen
display, so what-you-see is what-you-get across UIs, operating systems
and PNG output.

\end{aosasect2}

\begin{aosasect2}{Artist layer}

The Artist hierarchy is the middle layer of the matplotlib stack, and
is the place where much of the heavy lifting happens.  Continuing with
the analogy that the FigureCanvas from the backend is the paper, the
Artist is the object that knows how to take the Renderer (the
paintbrush) and put ink on the canvas.  Everything you see in a
matplotlib Figure is an Artist instance: the title, the lines, the
tick labels, the images, and so on all correspond to individual Artist
instances.  The base class is \code{matplotlib.artist.Artist} and
contains attributes every Artist shares: the transformation which
translates the artist coordinate system to the canvas coordinate
system (discussed in more detail below), the visibility, the clip box
which defines the region the artist can paint into, the label, and the
interface to handle user interaction such as "picking", ie detecting
when a mouse click happens over the artist.

The coupling between the Artist hierarchy and the backend happens in
the draw method.  For example, in the mockup class below where we
create "SomeArtist" which derives from the base class Artist, the
essential method that SomeArtist must implement is \code{draw} which
is passed a renderer from the backend.  The Artist doesn't know what
kind of backend the renderer is going to draw onto, PDF, SVG, GTK
DrawingArea, etc, but it does know the Renderer API and will call the
appropriate method (\code{draw\_text}, \code{draw\_path}.  Since the
Renderer has a pointer to its canvas and knows how to paint onto it,
the draw method transfers the abstract representation of the Artist to
colors in a pixel buffer, or paths in an SVG file, etc \dots{}.

\begin{verbatim}
class SomeArtist(Artist):
    'an example Artist that implements the draw method'

    def draw(self, renderer):
        'call the approriate renderer methods to paint self onto canvas'
        if not self.get_visible():  return

	# create some objects and use renderer to draw self here
	renderer.draw_path(graphics_context, path, transform)

\end{verbatim}

There are two types of Artists in the hierarchy \emph{Primitive}
artists represent the kinds of objects you see in a plot:
\code{Line2D}, \code{Rectangle}, \code{Circle}, \code{Text}.
\emph{Composite} artists are collections of Artists such as the
\code{Axis}, \code{Tick}, \code{Axes}, and \code{Figure}.  Each
composite artist may contain other composite artists as well as
primitive artists, eg the Figure contains one or more composite Axes
and the background of the Figure is a primitive Rectangle.

The most important composite artist is the Axes, which is where most
of the matplotlib API plotting methods are defined.  Not only does the
Axes contain most of the graphical elements that make up the
background of the plot -- the ticks, the axis lines, the grid, the
patch of color which is the plot background -- it contains numerous
helper methods that create primitive artists and add them to the Axes
instance.  For example, the table below shows a small sampling of Axes
methods that create plot objects and store them in the Axes instance.

\begin{table}[t]\scriptsize\centering
\begin{tabular}[c] { | l | l | l | }
\hline
\textbf{method}                     & \textbf{creates}                                                  & \textbf{stored in}            \\
\hline
\code{Axes.imshow}         &  one or more \code{matplotlib.image.AxesImage}s          & \code{Axes.images}   \\
\code{Axes.hist}           &  many \code{matplotlib.patch.Rectangle}s                 & \code{Axes.patches}  \\
\code{Axes.plot}           &  one or more \code{matplotlib.lines.Line2D}s             & \code{Axes.lines}\\
\hline

\end{tabular}
\caption{Sampling of \code{Axes} methods and the \code{Artist} instances they create}
\label{tbl.matplotlib.axmethods}
\end{table}


\end{aosasect2}

\begin{aosasect2}{Scripting layer (pyplot)}
\end{aosasect2}


\end{aosasect1}


\begin{aosasect1}{Backend refactoring}
% [Write something about backends in general... - MGD]

Over time, the drawing API of the output backends grew a large number
of methods, including:

\begin{verbatim}
draw_arc, draw_image, draw_line_collection, draw_line, draw_lines, draw_point,
draw_quad_mesh, draw_polygon_collection, draw_polygon, draw_rectangle,
draw_regpoly_collection
\end{verbatim}

Unfortunately, having more backend methods meant it took much longer
to write a new backend, and even maintaining the existing ones took
considerable effort.  Adding a new feature, such as polygon
collections, required adding support for it to each backend.  Since
each of the backends was implemented by a single developer who was
expert in the output file format, it sometimes took a long time for a
new feature to arrive in all of the backends, causing confusion for
the user about which features were available where.

For matplotlib 0.98, the backends were refactored to require only the
minimum necessary functionality in the backends themselves, with
everything else moved into the core.  The number of required methods
in the backend API was reduced considerably, to only:

\begin{aosaitemize}

  \item \code{draw\_path}: Draw compound polygons, with optional
    B\'ezier segments

  \item \code{draw\_image}: Draw raster images

  \item \code{draw\_text}: Draw text with the given font properties

  \item \code{get\_text\_width\_height\_descent}: Given a string of
    text, return its metrics

\end{aosaitemize}

It is possible to implement all of the drawing necessary for a new
backend using only these methods.  This is useful for getting a new
backend up-and-running more easily.  However, in some cases, a backend
may want to override the behavior of the core in order to create more
efficient output.  For example, when drawing markers, it is more space
efficient to write the marker's shape only once to the file, and then
repeat it as a ``stamp'' everywhere it is used.  In that case, the
backend can implement a \code{draw\_markers} method.  If it is
implemented, the backend writes out the marker shape once as an
``object'' and then writes out a much shorter command to reuse it in
a number of locations.  If it is not implemented, the core simply
draws the marker multiple times using multiple calls to
\code{draw\_path}.

The full list of optional backend API methods is:

\begin{aosaitemize}

  \item \code{draw\_markers}: Draw a set of markers

  \item \code{draw\_path\_collection}: Draw a collection of paths

  \item \code{draw\_quad\_mesh}: Draw a quadrilateral mesh

\end{aosaitemize}

\end{aosasect1}

\begin{aosasect1}{Transforms}
An important part of the work that matplotlib does when plotting is in
transforming from one coordinate system to another.  Every artist has
a transformation node that knows how to transform its logical
coordinates (generally the coordinates the user provided) to output
coordinates on the figure.  These transformation nodes are connected
together in a tree, where each node is dependent on its parent.  When
a parent's transformation changes, such as when a figure window is
resized, the children are all invalidated and the location of any
artists using those nodes must be recomputed.  This invalidation
approach prevents unnecessary recomputations of the entire artist tree
and contributes to better interactive performance.

Transform nodes may be either simple affine transformations (scale,
translation, rotation and skew) or non-affine transformations.
Two-dimensional affine transformations are represented using a $3
\times 3$ affine transformation matrix.  2D dimensional coordinates can
then easily be transformed by simply multiplying them by the
transformation matrix.  Affine transformations also have the useful
property that they can be composed together using matrix
multiplication.  This means that to perform a series of affine
transformations, the transformation matrices can first be multiplied
together only once, and the resulting matrix can be used to transform
coordinates.  matplotlib's transformation framework automatically
composes (freezes) affine transformation matrices together before
transforming coordinates to reduce the amount of computation.

The non-affine transformations in matplotlib are defined using Python
functions, so they are truly arbitrary.  Within the matplotlib core,
non-affine transformations are used for logarithmic scaling [EXAMPLE],
polar plots [EXAMPLE] and geographical projections (Mercator etc.).
These non-affine transformations can be freely mixed with affine ones
in the transformation tree.  matplotlib will automatically simplify
the affine portion and only fall back to the arbitrary functions for
the non-affine portion.

% Show an example transformation tree and how parts of it may get
% invalidated

\end{aosasect1}

\begin{aosasect1}{The polyline pipeline}

When plotting line plots, there are a number of steps that are
performed to get from the raw data to the line drawn on screen.  In an
earlier version of matplotlib, all of these steps were tangled
together.  These have since been refactored so they are discrete steps
in a ``path conversion'' pipeline.  This allows each backend to choose
which parts of the pipeline to perform, since some are only relevant
for certain backends.

\begin{aosaenumerate}

\item \textbf{Transformation:} The coordinates are transformed from data
  coordinates to figure coordinates.  If this is a purely affine
  transformation, as described above, this is as simple as a matrix
  multiplication.  If this involves arbitrary transformations,
  transformation functions are called to transform the coordinates
  into figure space.

\item \textbf{Handle missing data:} The data array may have portions
  where the data is missing or invalid.  The user may indicate this
  either by setting those values to NaN, or using Numpy masked arrays.
  Vector output formats, such as PDF, do not have a concept of missing
  data when plotting a polyline, so this step of the pipeline must
  skip over the missing data segments using MOVETO commands.

\item \textbf{Clipping:} Points outside of the boundaries of the
  figure can increase the file size with invisible points, and, more
  importantly, very large or very small coordinate values can cause
  overflow errors in the rendering of the output file, resulting in
  completely garbled output.  This step of the pipeline clips the
  polyline as it exits and enters the edges of the figure to prevent
  both of these problems.

\item \textbf{Snapping:} Perfectly vertical and horizontal lines can
  look fuzzy due to antialiasing when their centers are not aligned to
  the center of a pixel.  The snapping step of the pipeline first
  determines whether the entire polyline is made up of horizontal and
  vertical segments (such as an axis-aligned rectangle), and if so,
  rounds each resulting vertex to the nearest pixel center.  This step
  is only produced for raster backends, since vector backends should
  continue to have exact data points.  Some renderers of vector file
  formats, such as Adobe Acrobat, perform pixel snapping when viewed
  on screen.

\item \textbf{Simplification:} When plotting really dense plots, many
  of the points on the line may not actually be visible.  Including
  these points in the plot increases file size, and may hit limits on
  the number of points allowed in the file format.  Therefore, any
  points that lie exactly on the line between their two neighboring
  points are removed.

\end{aosaenumerate}

% TODO: Provide an example for each of the above

\end{aosasect1}

\begin{aosasect1}{Math text}

It is often very useful to put richly-formatted math expressions
directly on the plot.  Perhaps the most widely-used syntax for math
expressions is from Donald Knuth's \TeX\ typesetting system.  It's a
way to turn input like this:
\begin{verbatim}
\sqrt{\frac{\delta x}{\delta y}}
\end{verbatim}
into this:
\begin{math}
\sqrt{\frac{\delta x}{\delta y}}
\end{math}

matplotlib provides two ways to render math expressions.  The first,
usetex, uses a full copy of \TeX\ on the user's machine to render the
math expression and then inserts it into the plot.  However, the user
may not always have a full working installation of \TeX\, so
matplotlib also includes its own internal math rendering engine,
called mathtext.

mathtext is a direct port of the most important subset of the
\TeX\ math-rendering engine, glued onto a much simpler parser written
using the pyparsing (CITE) parsing framework.  This port was written
based on the published copy of the \TeX\ source code (CITE).  The
simple parser builds up a tree of boxes and glue (in
\TeX\ nomenclature), that are then layed out by the layout engine.

\end{aosasect1}


\end{aosachapter}


