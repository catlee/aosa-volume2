\begin{aosachapter}{Git}{s:git}{Susan Potter}

Work in progress\ldots

Git is an open source distributed Version Control System (dVCS) that was
born out of the needs and frustrations of the Linux Kernel development
community in 2005.

Git enables the management of a digital body of work (often,
but not limited to, code) across a peer-to-peer network of
collaborating repositories. It supports distributed workflows to
manage a body of work that is either eventually converging or
diverging in nature. A feat not easily accomplished
using a centralized Version Control System (VCS) such as CVS or
Subversion, the two most popular open source centralized VCS
projects.

\begin{aosasect1}{History}
To understand Git better it is helpful to understand the circumstances
from which the Git project was started in the Linux Kernel community.

The Linux Kernel was first released in October 1991. It rapidly grew a community
of core developers and contributors by the mid-to-late 1990s. Along side
individuals adopting Linux there were organisations or teams of developers
creating Linux distributions based on top of the Linux Kernel project by
the close of the decade. These distributions would sometimes temporarily
fork the official version of the kernel if patches relevant to their user
base were not yet included in the Kernel project when releasing new
versions of their distribution.

By the late 1990s Torvalds and other core developers voiced concerns
about managing patches from a large number of contributors for the
Kernel codebase using any of the open source VCSes available to them at
that time.

Between late 1999 and early 2005 many of the core developers of the Linux
Kernel opted to use BitKeeper, a proprietary distributed VCS made by
BitMover Inc. This was a contraversial move by arguably the best known open
source project at that time, a decision questioned by Richard Stallman, the
GNU project founder. Several key Linux Kernel developers (including Alan Cox)
refused to use BitKeeper, due to concerns over the proprietary Bitmover
license. By 2002 BitMover provided a way for the Linux BitKeeper servers to
interoperate with the Linux CVS server in a few ways. It offered a
public release and free use of its servers to a shortlist of free and
open source projects including the Linux Kernel. For a few years the
Linux Kernel would be maintained across two VCS systems in this way.

This ended during the first half of 2005, when BitMover retracted its
"Free Use" version for a number of key Linux Kernel developers and Git
was born to fill the void.

In April 2005, days after the BitMover announcement, Linus Torvalds began
development in haste of what was to become Git as we know it today. He began
by writing a collection of scripts to help him manage email patches
to apply one after the other. The aim of this initial collection of scripts
was to fail merges quickly so the maintainer could modify the codebase mid-
patch stream and continue merging contributed patches once cleanly able to.

Torvald's had one philosphical goal for Git - to embody the anti-CVS - plus
three technical goals from the outset:
\begin{aosaitemize}
  \item support distributed workflows like those enabled by BitKeeper
  \item offer safeguards against content corruption
  \item offer high performance
\end{aosaitemize}

Despite BitKeeper influencing the original design of Git, it is implemented
in fundamentally different ways and allows even more distributed and even
local-only workflows, which weren't possible with BitKeeper.

Around this time (c2005) three other open source distributed VCS projects
were initiated, including Mercurial, which was a project covered in volume 1
of this title series.

\end{aosasect1}

\begin{aosasect1}{The Toolkit}

Today the Git ecosystem posesses many GUIs on a number of operating systems.
These are mostly built on top of the Git core toolkit.

Due to the way Git was originally written by Linus and its inception within
the Linux community it was written with a toolkit design philosphy very much
in the Unix tradition of command line tools.

The Git toolkit is divided into two parts: the plumbing and
the porcelain. The plumbing consists of low-level commands that enable
the manipulation of directed acyclic graphs (DAG) and basic content
tracking. The porcelain is the smaller subset of git commands that most
end-users of Git are likely to need to use for maintaining repositories and
communicating between repositories for collaboration.

While the toolkit design has provided enough commands to offer fine grained
access to functionality for many scripters, application developers
complained about the lack of a linkable library for Git. Since the Git binary
calls die(), it was not reentrant and GUIs, web interfaces or longer running
services would have to fork/exec a call to the Git binary, which can be slow.

Shawn Pearce spearheaded an effort to create a linkable Git library with
more permissive licensing that didn't inhibit use of the library. This was
called libgit2. It didn't find much traction until a student named, Vincent
Marti chose it for his Google Summer of Code project last year. Since then
Vincent and GitHub have continued contributing to the libgit2 project and
created Ruby bindings for it in a project called Rugged. More recently
Python bindings around libgit2 have emerged in an open source project
called pygit2. These three open source projects are maintained independently
of the Git core project.

As you can see today there is a wide array of ways to integrate with Git.
From the plumbing portion of the toolkit, procelain layer and now the
linkable library, libgit2 and its offshoots.
\end{aosasect1}

\begin{aosasect1}{The Repository}

Let us get our hands dirty and dive into using Git locally, if only to
understand a few fundamental concepts.

First to create a new initialized Git repository on our local filesystem
(using a Unix inspired operating system) we can do:
\begin{aosaitemize}
  \item \code{mkdir testgit}
  \item \code{cd testgit}
  \item \code{git init}
\end{aosaitemize}

Now we have an empty, but initialized Git repository sitting in our testgit
directory. We can branch, commit, tag and even communicate with other local
and remote Git repositories. Even communication with other types of VCS
repositories is possible with just a handful of \code{git} commands.

The \code{git init} command creates a .git subdirectory inside of testgit.
Let us have a peak inside of it:
\begin{aosaitemize}
  \item \code{tree .git/}\newline
  \code{
.git/\newline
|-- HEAD\newline
|-- config\newline
|-- description\newline
|-- hooks\newline
|   |-- applypatch-msg.sample\newline
|   |-- commit-msg.sample\newline
|   |-- post-commit.sample\newline
|   |-- post-receive.sample\newline
|   |-- post-update.sample\newline
|   |-- pre-applypatch.sample\newline
|   |-- pre-commit.sample\newline
|   |-- pre-rebase.sample\newline
|   |-- prepare-commit-msg.sample\newline
|   |-- update.sample\newline
|-- info\newline
|   |-- exclude\newline
|-- objects\newline
|   |-- info\newline
|   |-- pack\newline
|-- refs\newline
    |-- heads\newline
    |-- tags\newline
}
\end{aosaitemize}

The .git directory above is by default located inside the root working
directory, testgit. It contains a few different types of files and
directories:
\begin{aosaitemize}
  \item \emph{Configuration}: the .git/config, .git/description and
  .git/info/exclude files essentially help configure the local repository.
  \item \emph{Hooks}: the .git/hooks directory contains scripts that can
  be run on certain lifecycle events of the repository.
  \item \emph{Staging Area}: the .git/index file (which is not yet
  present in our tree listing above) will provide a staging area for our
  working directory.
  \item \emph{Object Database}: the .git/objects directory is the default
  Git object database, which contains all content or pointers to local content.
  \item \emph{References}: the .git/refs directory is the default location
  for storing reference pointers for both local and remote branches, tags and
  heads.
\end{aosaitemize}


\end{aosasect1}

\begin{aosasect1}{The Object Database}

Git has four basic primitive objects that every containing content in the local
repository is built on top of. Each object type above has the following
attributes: \emph{type}, \emph{size} and \emph{content}. The primitive object
types are:
\begin{aosaitemize}
  \item \emph{Tree}: elements in a tree can be another tree or a blob when
  representing a content directory.
  \item \emph{Blob}: a blob represents a file stored in the repository.
  \item \emph{Commit}: a commit points to a tree representing the top level
  directory for that commit as well as parent commits and standard attributes.
  \item \emph{Tag}: a tag has a name and points to a commit at the point in the
  repository history that the tag represents
\end{aosaitemize}

\aosafigure{../images/git/git-objects.png}{Git Objects}{fig.git.objects}

All object primitives are referenced by a SHA, a 40-digit object identity,
which has the following properties:
\begin{aosaitemize}
  \item if two objects are identical they will have the same SHA
  \item if two objects are different they will have different SHAs
  \item if an object was only copied partially or another form of data
        corruption occurred, recalculating the SHA of the current object
        will identify such corruption
\end{aosaitemize}

The first two properties of the SHA relating to identity of the objects is
most useful to enable Git's distributed model (the second goal of Git).
The latter property enables some safegaurds against corruption (the third goal
of Git above).

In many ways Git can be thought of as a content tracking filesystem living on top
of your existing filesystem.

TODO: More to discuss here. Use plumbing commands like 'git show' and 'git cat-file'
to demonstrate how the primitives work together and build on top of each other.

\end{aosasect1}

\begin{aosasect1}{Version Control System (VCS) Landscape}

Now is a good time to take a step back and look at the alternative VCS soltuions
to Git. How the solutions differ will help us understand Git's importance and why
developers have been rapidly adopting it.

TODO: Flesh out this section. Overview:
* This section will describe the two primary classification dimensions to
Version Control Systems (VCS) today:

\begin{aosaitemize}
  \item Distribution mode: local, client/server, distributed
  \item Storage mode: changeset based vs directed acyclic graph (DAG) based
\end{aosaitemize}

Provide examples of different VCSes and how they fit in to these
classifications, e.g. Subversion (client/server + changeset), Mercurial
(distributed + changeset), BitKeeper (client/server + DAG), etc.

\end{aosasect1}

\begin{aosasect1}{Gitting Started}

TODO: This may still be included to show off more plumbing commands as well as the major
porcelain commands and also help explain repository-to-repository commands and
collaboration.

Here I will describe the most rudimentary workflow of installing, configuring
and cloning a remote Git repository. Then explain on a low-level what happened.

Describe the three main elements of a Git working environment:
\begin{aosaitemize}
  \item Repository (object database): default at \#\{projectdir\}/.git subdirectory
  \item Working area: default at \#\{projectdir\} excluding .git subdirectory
  \item Index: default at \#\{projectdir\}/.git/index file
\end{aosaitemize}

Basic steps:
\begin{aosaitemize}
  \item sudo yum install git-core
  \item git config --global user.name ``Your Name''
  \item git config --global user.email ``user@emaildomain.com''
  \item cat \#\{HOME\}/.gitconfig
  \item git clone remote-repo-url
\end{aosaitemize}

Mention the different protocols that can be used with Git, e.g. ssh, http,
https, git, file and even rsync. Broadly discuss pros and cons of each.

Protocols notes:
\begin{aosaitemize}
  \item file:// local repository easiest to setup, usuallly only useful for
    one author environment
  \item ssh:// most common for active development and easy to setup team repository
  \item http:// good for open source pull based (consumers) users, can setup with
    WebDAV support for allowing pushes, but more work. Good for working in
    restricted public networks where SSH ports may be blocked.
  \item https:// same as http except encrypts pulls and pushes over the wire.
  \item git:// lightweight protocol useful in an enclosed and trusted local network
  \item rsync:// hardly used.
\end{aosaitemize}

\end{aosasect1}

\begin{aosasect1}{Gitting Down \& Dirty}

Start with simplest of workflows: purely LOCAL. One author/editor local repo,
multiple contributors receive bundle of their branch from author/editor.
Contributors submit patches to author/editor (via email or ticketing system):
1. Contributor: git format-patch origin/master --stdout > my-feature.patch
2. Author: git am < my-feature.patch

Notice how GIT\_AUTHOR\_NAME and GIT\_AUTHOR\_EMAIL use the contributors
values and the editor's information is in GIT\_COMMITTER\_NAME, etc.

Make sure to cover: git config|init|add|commit|status|branch|tag|log|
format-patch|am|merge|rebase|bundle|diff

% This is how to include a figure using the AOSA styles already configured
%\aosafigure{../images/git/distworkflow.eps}{Distributed VCS}{fig.git.dvcs}

Discussion on distributed workflows\ldots

Introduce Git Flow workflow as a common one used in the Git community. Provide
a realistic example. Plus I need to create good diagrams to explain things
better.

Then introduce the ``fork'' workflow which is commonly seen on GitHub and
used by OSS projects.

Then introduce the tiered/curated workflow where a release engineer/manager
is gatekeeper. production-like environments do not have development branches
visible to them at all. More locked-down.

Then introduce the GitHub model with ``forks''.

\end{aosasect1}

\begin{aosasect1}{Deploying with Git}

Here talk a little more about 'git bundle' and git shallow clones, e.g.
git clone --depth N \#\{GIT\_URL\}, where N is the number of parents.

Demonstrate with a repository that shows significant benefit to using
bundle in conjunction with shallow clones as a way to provide portable
shall git repositories that allow deployment agents to transfer/receive
minimal bytes over the wires AND have ability to do rollbacks in severe
cases where a release does not go as planned.

\end{aosasect1}

\end{aosachapter}
