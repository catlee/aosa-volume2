<html>
<head>
<title>Yesod Web Framework</title>
</head>
<body>
<h1>Yesod</h1>
<section class="subtopic" id="file1394-introduction">
<h1>Introduction</h1>
  <p class="hascomments" id="file1394-introduction-x-3">Yesod is a web framework written in the Haskell programming language. Development began about
   two years ago, and has been going strong ever since. Yesod cut its teeth on real life projects,
   with all of its initial features borne out of an actual, real life need. After being developed
   mostly single-handedly for about a year, the community efforts kicked in, and Yesod has since
   blossomed into a thriving open-source project.</p>
  <p class="hascomments" id="file1394-introduction-x-4">During the embryonic phase, when Yesod was incredibly ephemeral and ill-defined, it
   would have been counter-productive to try and get a team to work on it. By the time it stabilized
   enough to be useful to others, it was the right time to find out the downsides to some of the
   decisions that had been made. Since then, we have made major changes to the user-facing API to
   make it more useful, and are quickly solidifying a 1.0 release.</p>
  <p class="hascomments" id="file1394-introduction-x-5">The question you may ask is: why another web framework? I&#39;ll start with a redirect to a
   different question: why use Haskell? It seems that most of the world is happy with one of two
   styles of language:</p>
  <ul id="file1394-introduction-ul_abba76f6-38db-46aa-8bd9-4699289ea8d4">
   <li id="file1394-introduction-x-6">Statically typed languages, like Java, C# and C++. These languages provide speed and type
    safety, but are more cumbersome to program with.</li>
   <li id="file1394-introduction-x-7">Dynamically typed languages, like Ruby and Python. These languages greatly increase
    productivity (at least in the short run), but run slowly and have very little support from the
    compiler to ensure correctness. (The solution to this last point is unit testing. We&#39;ll get to
    that later.)</li>
  </ul>
  <p class="hascomments" id="file1394-introduction-x-8">This is a false dichotomy. There&#39;s no reason why statically typed languages need to be
   so clumsy. Haskell is able to capture a huge amount of the expressivity of Ruby and Python, while
   still keeping a strongly typed language. In fact, Haskell&#39;s type system catches many more bugs
   that Java and its ilk. Null pointer exceptions are completely eliminated; immutable data
   structures simplify reasoning about your code and simplify parallel and concurrent
   programming.</p>
  <p class="hascomments" id="file1394-introduction-x-9">So why Haskell? It is an efficient, developer-friendly language which provides many
   compile-time checks of program correctness.</p>
  <p class="hascomments" id="file1394-introduction-x-10">The goal of Yesod is to extend Haskell&#39;s strengths into web development. We strive to make your
   code as concise as possible. As much as possible, every line of your code is checked for
   correctness at compile time. Instead of requiring large libraries of unit tests to test basic
   properties, the compiler does it all for you. And under the surface, we use as many advanced
   performance techniques as we can muster to make your high-level code fly.</p>
 </section><section class="subtopic" id="file1483-conceptId"><h1>Compared to other frameworks</h1>
  <p class="hascomments" id="file1483-conceptId-x-3">In general terms, Yesod is more similar than different when compared to the leading frameworks,
   such as Rails and Django. It generally follows the Model-View-Controller (MVC) paradigm, has a
   templating system that separates view from logic, provides an Object Relational Mapping (ORM)
   system, and has a front controller approach to routing.</p>
  <p class="hascomments" id="file1483-conceptId-x-4">The devil is in the details. Yesod strives to push as much error catching to the compile phase
   instead of runtime, and to automatically catch both bugs and security flaws through the type
   system. And while it tries to maintain a user-friendly, high-level API, it uses a number of newer
   techniques from the functional programming world to achieve high performance, and is not afraid
   to expose these internals to developers.</p>
  <p class="hascomments" id="file1483-conceptId-x-5">The main architectural challenge in Yesod is balancing these two seemingly conflicting goals.
   For example, there is nothing revolutionary about Yesod&#39;s approach to routing (called <a href="http://www.yesodweb.com/redirector/home%2F1%2Fwriting%2Faosa%2Fyesod%2Froutes.dita">type-safe URLs</a>). Historically, implementing
   such a solution was a tedious, error-prone process. Yesod&#39;s innovation is to use Template Haskell
   (a form of code generation) to automate the boilerplate required to bootstrap the process.
   Similarly, type-safe HTML has been around for a long while; Yesod tries to keep the developer
   friendly aspect of common template languages while keeping the power of type safety.</p>
 </section><section class="subtopic" id="file1401-conceptId"><h1>Web Application Interface</h1>
  <p class="hascomments" id="file1401-conceptId-x-3">A web application needs some way to communicate with a server. One possible approach is to bake
   the server directly into the framework, but doing so necessarily limits your options for
   deployment and leads to poor interfaces. Many languages have created standard interfaces to
   address this issue: Python has WSGI and Ruby has Rack. In Haskell, we have WAI.</p>
  <p class="hascomments" id="file1401-conceptId-x-4">WAI is not intended to be a high level interface. It has two specific goals:
   generality and performance. By staying general WAI has been able to support backends for
   everything from standalone servers to old school CGI and even works directly with Webkit to
   produce faux desktop applications. The performance side will introduce us to a number of the cool
   features of Haskell.</p>
  
 <section class="subtopic" id="file1395-conceptId"><h1>Datatypes</h1>
  <p class="hascomments" id="file1395-conceptId-x-3">One of the biggest advantages of Haskell - and one of the things we make the most use of in
   Yesod - is strong static typing. Before we begin to write the code for how to solve something, we
   need to think about what the data will look like. WAI is a perfect example of this paradigm. The
   core concept we want to express is that of an application. An application&#39;s most basic expression
   is a function that takes a request and returns a response. In Haskell lingo:
   <pre class="codeblock" id="file1395-conceptId-x-4">type Application = Request -&gt; Response</pre></p>
  <p class="hascomments" id="file1395-conceptId-x-5">But that just begs the question: what do Request and Response look like? A Request has a number
   of pieces of information, but the most basic are the requested path, query string, request
   headers, and request body. And a Response has just three components: a status, response headers
   and response body.</p>
  <p class="hascomments" id="file1395-conceptId-x-6">How do we represent something like a query string? Haskell keeps a strict separation between
   binary and textual data. The former is represented by ByteString, the latter by Text. Both are
   highly optimized datatypes that provide a high level, safe API. In the case of query string we
   store the raw bytes transferred over the wire as a ByteString and the parsed, decoded values as
   Text. </p>
 </section><section class="subtopic" id="file1396-conceptId"><h1>Streaming</h1>
  <p class="hascomments" id="file1396-conceptId-x-3">A ByteString represents a single memory buffer. If we were to naively use a plain ByteString
   for holding the entire request or response bodies, our applications could never scale to large
   requests or responses. Instead, we use a technique called enumerators, very similar in concept to
   generators in Python. Our application becomes a consumer of a stream of ByteStrings representing
   the incoming request body, and a producer of a separate stream for the response.</p>
  <p class="hascomments" id="file1396-conceptId-x-4">We now need to slightly revise our definition of an application. An application will take a
   request value, containing headers, query string, etc, and will consume a stream of ByteStrings,
   producing a Response. So our actual definition of an Application
   is:<pre class="codeblock" id="file1396-conceptId-x-5">type Application = Request -&gt; Iteratee ByteString IO Response</pre>The IO
   simply explains what types of side effects an application can perform. In the case of IO, it can
   perform any kind of interaction with the outside world, an obvious necessity for the vast
   majority of web applications.</p>
 </section><section class="subtopic" id="file1397-conceptId"><h1>Builder</h1>
  <p class="hascomments" id="file1397-conceptId-x-3">The trick in our arsenal is how we produce our response buffers. We have a few competing
   desires here: On the one hand, we want to minimize system calls for sending data over the socket.
   To do this we need to store outgoing data in a buffer. However, if we make this buffer too large,
   we will exhaust our memory and slow down the application&#39;s response time. Finally, we want to
   minimize the number of times data is copied between buffers.</p>
  <p class="hascomments" id="file1397-conceptId-x-4">Haskell&#39;s solution to this is the builder. A builder is an instruction for how to fill the
   memory buffer, such as place the five bytes &quot;hello&quot; in the next open position. Instead of passing
   a stream of memory buffers to the server, a WAI application passes a stream of these
   instructions. The server takes the stream and uses it to fill up optimally sized memory buffers.
   As each buffer is filled, the server makes a system call to send the data over over the wire and
   then starts filling up the next buffer.<aside class="note" id="file1397-conceptId-x-5">The optimal size for a buffer will depend on many
    factors such as cache size. The underlying blaze-builder library underwent significant
    performance testing to determine the best trade-off.</aside></p>
  <p class="hascomments" id="file1397-conceptId-x-6">In theory, this kind of optimization could be performed in the application itself. However, by
   hoisting it into the interface, we are able to simply prepend the response headers to the
   response body. The result is that, for small to medium sized responses, the entire response can
   be sent with a single system call and memory being copied only once.</p>
 </section><section class="subtopic" id="file1398-conceptId"><h1>Handlers</h1>
  <p class="hascomments" id="file1398-conceptId-x-3">Now that we have an application, we need some way to run it. In WAI parlance, this is a
    <dfn id="file1398-conceptId-x-4">handler</dfn>. WAI has some basic, standard handlers, such as a standalone server (Warp,
   discussed below), FastCGI, SCGI and CGI. This spectrum allows WAI applications to be run on
   anything from dedicated servers down to shared hosting. But in addition to these, WAI has some
   more interesting backends:<dl id="file1398-conceptId-x-5">
    
     <dt id="file1398-conceptId-x-7">Webkit</dt>
     <dd id="file1398-conceptId-x-8">This backend embeds a Warp server and calls out to QtWebkit. By launching a server,
      followed by launching a new standalone browser window, we have faux desktop applications.</dd>
    
    
     <dt id="file1398-conceptId-x-10">Launch</dt>
     <dd id="file1398-conceptId-x-11">This is a slight variant on Webkit. Having to deploy the Qt and Webkit libraries can be a
      bit burdensome, so instead we just launch the user&#39;s default browser.</dd>
    
    
     <dt id="file1398-conceptId-x-13">Test</dt>
     <dd id="file1398-conceptId-x-14">And even testing counts as a handler. After all, testing is simply the act of running an
      application and inspecting the responses.</dd>
    
   </dl></p>
  <p class="hascomments" id="file1398-conceptId-x-15">Most developers will likely use Warp. It is lightweight enough to be used for testing. It
   requires no config files, no folder hiearchy and no long-running, administrator owned process.
   It&#39;s a simple library that gets compiled into your application or run via the Haskell
   interpreter. On the flip side, Warp is an incredibly fast server, with protection from all kinds
   of attack vectors, such as slow loris and infinite headers. Warp can be the only web server you
   need, though it is also quite happy to sit behind a reverse HTTP proxy.</p>
  <figure id="file1398-conceptId-x-16"><figcaption>Warp PONG Benchmark</figcaption>
   
   <img id="file1398-conceptId-image_xrh_agm_gd" src="extra-large.png" />
  </figure>
  <p class="hascomments" id="file1398-conceptId-x-18">Most of the reasons for Warp&#39;s speed have already been spelled out in the overall description
   of WAI: enumerators, builders and packed datatypes. The last piece in the puzzle is from GHC&#39;s
   multithreaded runtime. GHC, Haskell&#39;s flagship compiler, has light-weight green threads. Unlike
   system threads, it is possible to spin up thousands of these without serious performance hits.
   Therefore, in Warp, each connection is handled by its own green thread.</p>
  <p class="hascomments" id="file1398-conceptId-x-19">The next trick is asynchronous I/O. Any web server hoping to scale to tens of thousands of
   requests per second will need some type of asynchronous communication. In most languages, this
   involves complicated programming involving callbacks. GHC lets us cheat: we program as if we&#39;re
   using a synchronous API, and GHC automatically switches between different green threads waiting
   for activity.</p>
  <p class="hascomments" id="file1398-conceptId-x-20">Under the surface, GHC uses whatever system is provided by the host operating system, such as
   kqueue, epoll and select. This gives us all the performance of an event-based IO system, without
   worrying about cross-platform issues or writing in a callback-oriented way.</p>
 </section><section class="subtopic" id="file1399-conceptId"><h1>Middleware</h1>
  <p class="hascomments" id="file1399-conceptId-x-3">In between handlers and applications, we have middlewares. Technically, a middleware is an
    <dfn id="file1399-conceptId-x-4">application transformer</dfn>: it takes one application, and returns a new one. This is
   defined as <code id="file1399-conceptId-x-5">type Middleware = Application -&gt; Application</code>. But the best way to
   understand the purpose of a middleware is to look at some common ones:<ul id="file1399-conceptId-ul_kau_msu_id">
    <li id="file1399-conceptId-x-6">gzip automatically compresses the response from an application.</li>
    <li id="file1399-conceptId-x-7">jsonp automatically converts JSON responses to <a href="http://en.wikipedia.org/wiki/JSONP">JSON-P</a>
     responses when the client provided a callback parameter.</li>
    <li id="file1399-conceptId-x-9">autohead will generate appropriate HEAD responses based on the GET response of an
     application.</li>
    <li id="file1399-conceptId-x-10">debug will print debug information to the console or a log on each request.</li>
   </ul></p>
  <p class="hascomments" id="file1399-conceptId-x-11">The theme here is to factor out common code from applications and let it be shared easily. Note
   that, based on the definition of a middleware, we can easily stack these things up. The general
   workflow of a middleware is:<ol id="file1399-conceptId-ol_npi_zsu_id">
    <li id="file1399-conceptId-x-12">Take the request value and apply some modifications.</li>
    <li id="file1399-conceptId-x-13">Pass the modified request to the application and receive a response.</li>
    <li id="file1399-conceptId-x-14">Modify the response and return it to the handler.</li>
   </ol>In the case of stacked middlewares, instead of passing to the application or handler, the
   middleware will actually be passing to the inner and outer middlewares, respectively.</p>
 </section><section class="subtopic" id="file1400-conceptId"><h1>wai-test</h1>
  <p class="hascomments" id="file1400-conceptId-x-3">No amount of static typing will obviate the need for testing. We all know that automated
   testing is a necessity for any serious applications. wai-test is the recommended approach to
   testing a WAI application. Since requests and responses are simple datatypes, it&#39;s very easy to
   mock up a fake request, pass it to an application, and test properties about the response.
   wai-test simply provides some convenience functions for testing common properties like the
   presence of a header or a status code.</p>
 </section></section><section class="subtopic" id="file1406-conceptId"><h1>Templates</h1>
  <p class="hascomments" id="file1406-conceptId-x-3">In the typical Model-View-Controller (MVC) paradigm, one of the goals is to separate logic from
   the view. Part of this separation is achieved through the use of a template language. However,
   there are many different ways to approach this issue. At one end of the spectrum, for example,
   PHP/ASP/JSP will allow you to embed any arbitrary code within your template. At the other end,
   you have systems like StringTemplate and QuickSilver, which are passed some arguments and have no
   other way of interacting with the rest of the program.</p>
  <p class="hascomments" id="file1406-conceptId-x-4">Each system has its pros and cons. Having a more powerful template system can be a huge
   convenience. Need to show the contents of a database table? No problem, pull it in with the
   template. However, such an approach can quickly lead to convoluted code, interspersing database
   cursor updates with HTML generation. Most anyone who has worked on a poorly written ASP project
   has seen this.</p>
  <p class="hascomments" id="file1406-conceptId-x-5">While weak template systems make for simple code, they also tend towards a lot of redundant
   work. You&#39;ll often need to not only keep your original values in datatypes, but also create
   dictionaries of values to pass to the template. Maintaining such code is not easy, and usually
   there is no way for a compiler to help you out.</p>
  <p class="hascomments" id="file1406-conceptId-x-6">Yesod&#39;s family of template languages, the Shakespearean languages, strive for a middle ground.
   By leveraging Haskell&#39;s standard referential transparency, we can be assured that our templates
   produce no side effects. However, they still have full access to all the variables and functions
   available in your Haskell code. Also, since they are fully checked for both well-formedness,
   variable resolution and type safety at compile time, typos are much less likely to have you
   searching through your code trying to pin down a bug.</p>
  <aside class="note" id="file1406-conceptId-x-7">Why the name Shakespeare? The HTML language, Hamlet, was the first language written, and
   originally based its syntax on Haml. Since it was at the time a &quot;reduced&quot; Haml, Hamlet seemed
   appropriate. As we added CSS and Javascript options, we decided to keep the naming theme with
   Cassius and Julius. At this point, Hamlet looks nothing like Haml, but the name stuck
   anyway.</aside>
 <section class="subtopic" id="file1402-conceptId"><h1>Types</h1>
  <p class="hascomments" id="file1402-conceptId-x-3">If you haven&#39;t noticed yet, one of the overarching themes in Yesod is proper use of types to
   make our life easier. In our templates, we have two main examples:<ol id="file1402-conceptId-ol_pnw_rvy_id">
    <li id="file1402-conceptId-x-4">All content embedded into a Hamlet template must have a type of <code id="file1402-conceptId-x-5">Html</code>. As
     we&#39;ll see later, this forces us to properly escape dangerous HTML when necessary, while
     avoiding accidental double-escaping as well.</li>
    <li id="file1402-conceptId-x-6">Instead of concatenating URLs directly in our template, we have datatypes- known as
     type-safe URLs- which represent the routes in our application.</li>
   </ol></p>
  <p class="hascomments" id="file1402-conceptId-x-7">Let&#39;s see some real-life examples of this stuff. Suppose that a user submits his/her
   name to your application via a form. This data would be represented with the Text datatype. Now
   we would like to display this variable, called name, in a page. The type system- at compile time-
   prevents it from being simply stuck into a Hamlet template, since it&#39;s not of type Html. Instead
   we must convert it somehow. For this, there are two conversion functions:<ol id="file1402-conceptId-ol_sfn_nwy_id">
    <li id="file1402-conceptId-x-8">toHtml will automatically escape any entities. So if a user submits the string
      <code id="file1402-conceptId-x-9">&lt;script src=&quot;http://example.com/evil.js&quot;&gt;&lt;/script&gt;</code>, the
     less than signs will automatically be converted to <code id="file1402-conceptId-x-10">&amp;lt;</code>.</li>
    <li id="file1402-conceptId-x-11">preEscapedText, on the other hand, will leave the content precisely as it is
     now.</li>
   </ol>So in the case of untrusted input from a possibly nefarious user, toHtml would be our
   recommended approach. On the other hand, let&#39;s say we have some static HTML stored on our server
   that we&#39;d like to insert into some pages verbatim. In that case, we could load it into a Text
   value and then apply preEscapedText, thereby avoiding any double-escaping.</p>
  <p class="hascomments" id="file1402-conceptId-x-12">By default, Hamlet will use the toHtml function on any content you try to interpolate.
   Therefore, you only need to explicitly perform a conversion if you want to avoid escaping. This
   follows the dictum of erring on the side of caution.</p>
  <figure id="file1402-conceptId-x-13"><figcaption>Proper HTML Handling</figcaption>
   
   <pre class="codeblock" id="file1402-conceptId-x-15">name &lt;- runInputPost $ ireq textField &quot;name&quot;
snippet &lt;- readFile &quot;mysnippet.html&quot;
return [hamlet|
    &lt;p&gt;Welcome #{name}, you are on my site!
    &lt;div .copyright&gt;#{preEscapedText snippet}
|]</pre>
  </figure>
  <p class="hascomments" id="file1402-conceptId-x-16">The first step in type-safe URLs is creating a datatype that represents all the routes in your
   site. Let&#39;s say you have a site for displaying fibonnacci numbers. The site will have a separate
   page for each number in the sequence, plus the homepage. This could be modeled with the Haskell
   datatype<pre class="codeblock" id="file1402-conceptId-x-17">data FibRoute = Home | Fib Int</pre>We could then create a page like
   so:<pre class="codeblock" id="file1402-conceptId-x-18">&lt;p&gt;You are currently viewing number #{show index} in the sequence. Its value is #{show $ fib index}.
&lt;p&gt;
    &lt;a href=@{Fib ((+) index 1)}&gt;Next number
&lt;p&gt;
    &lt;a href=@{Home}&gt;Homepage</pre>Then
   all we need is some function to convert a type-safe URL into a string representation. In our
   case, that could look something like
   this:<pre class="codeblock" id="file1402-conceptId-x-19">render :: FibRoute -&gt; Text
render Home = &quot;/home&quot;
render (Fib i) = &quot;/fib/&quot; ++ show i</pre></p>
  <p class="hascomments" id="file1402-conceptId-x-20">Fortunately, all of the boilerplate of defining and rendering type-safe URL datatypes is
   handled for the developer automatically by Yesod. We will cover that in more depth later.</p>
 </section><section class="subtopic" id="file1404-conceptId"><h1>The Other Languages</h1>
  <p class="hascomments" id="file1404-conceptId-x-3">In addition to Hamlet, there are three other languages. Julius is used for Javascript. However,
   it&#39;s a simple pass-through language, just allowing for interpolation. In other words, barring
   accidental use of the interpolation syntax, any piece of Javascript could be dropped into Julius
   and be valid. (In fact, for testing performance, I once took jQuery and ran it through Julius
   without a hitch.)</p>
  <p class="hascomments" id="file1404-conceptId-x-7">The other two languages are alternate CSS syntaxes. Those familiar with the difference between
   Sass and Less will recognize this immediately: Cassius is whitespace delimited, while Lucius uses
   braces. Lucius is in fact a superset of CSS, meaning all valid CSS files are valid Lucius files.
   In addition to allowing text interpolation, there are some helper datatypes provided to model
   unit sizes and colors. Also, type-safe URLs work in these languages, making it convenient for
   specifying background images.</p>
  <p class="hascomments" id="file1404-conceptId-x-4">Besides all the type safety and compile-time checks mentioned above, having specialized
   languages for CSS and Javascript give us a few other advantages.</p>
  <ul id="file1404-conceptId-ul_agn_iwn_zd">
   <li id="file1404-conceptId-x-5">For production, all the CSS and Javascript is compiled into the final executable, increasing
    performance (by avoiding file I/O) and simplifying deployment.</li>
   <li id="file1404-conceptId-x-6">By being based around the efficient builder construct described earlier, this templates can
    render very quickly.</li>
   <li id="file1404-conceptId-x-8">There is built-in support for automatically including these in final webpages. We&#39;ll get into
    this in more detail when describing widgets below.</li>
  </ul>
 </section></section><section class="subtopic" id="file1412-persistent"><h1>Persistent</h1>
  <p class="hascomments" id="file1412-persistent-x-3">Most web applications will want to store information in a database. Traditionally, this has
   meant some kind of SQL database. In that regard, Yesod continues a long tradition, with
   PostgreSQL as our most commonly used backend. But as we have been seeing in recent years, SQL
   isn&#39;t always the answer to the persistence question. Therefore, Yesod was designed to work well
   with NoSQL databases as well, and ships with a MongoDB backend as a first-class citizen.</p>
  <p class="hascomments" id="file1412-persistent-x-4">The result of this design decision is Persistent, Yesod&#39;s preferred storage option. There are
   really two guiding lights for Persistent: make it as backend agnostic as possible, and let user
   code be completely type-checked.</p>
  <p class="hascomments" id="file1412-persistent-x-5">At the same time, we fully recognize that it&#39;s impossible to completely shield the user away
   from all details of the backend. Therefore, we provide two types of escape routes:</p>
  <ul id="file1412-persistent-ul_d97fb29c-e69e-46be-958c-331addbddd2f">
   <li id="file1412-persistent-x-6">Provide backend-specific functionality as necessary. For example, Persistent provides
    features for SQL joins and MongoDB lists and hashes. Proper portability warnings will apply, but
    if you want this functionality, it&#39;s there.</li>
   <li id="file1412-persistent-x-7">Easy access to performing raw queries. We don&#39;t believe it&#39;s possible for any abstraction to
    cover every use case of the underlying library. If you just have to write a 5-table, correllated
    subquery SQL query, go right ahead.</li>
  </ul>
 <section class="subtopic" id="file1407-terminology"><h1>Terminology</h1>
  <p class="hascomments" id="file1407-terminology-x-3">The most primitive datatype in Persistent is the <code id="file1407-terminology-x-4">PersistValue</code>. This represents
   any raw data that can appear within the database, such as a number, a date, or a string. Of
   course, sometimes you&#39;ll have some more user-friendly datatypes you want to store, like HTML. For
   that, we have the <code id="file1407-terminology-x-5">PersistField</code> class. Internally, a
    <code id="file1407-terminology-x-6">PersistField</code> expresses itself to the database in terms of a
    <code id="file1407-terminology-x-7">PersistValue</code>.</p>
  <p class="hascomments" id="file1407-terminology-x-8">All of this is very nice, but we&#39;ll really want to combine different fields together into a
   larger picture. For this, we have a <code id="file1407-terminology-x-9">PersistEntity</code>, which is basically a
   collection of <code id="file1407-terminology-x-10">PersistField</code>s. And finally, we have a
    <code id="file1407-terminology-x-11">PersistBackend</code> that describes how to create, read, update and delete these
   entities.</p>
  
  <p class="hascomments" id="file1407-terminology-x-12">As a practical example, consider storing a person in a database. We want to store the person&#39;s
   name, birthday, and a profile image (a PNG file). So we&#39;ll create a new entity
    <code id="file1407-terminology-x-13">Person</code> with three fields: a <code id="file1407-terminology-x-14">Text</code>, a <code id="file1407-terminology-x-15">Day</code> and a
    <code id="file1407-terminology-x-16">PNG</code>. Each of those get stored in the database using a different
    <code id="file1407-terminology-x-17">PersistValue</code> constructor: <code id="file1407-terminology-x-18">PersistText</code>,
    <code id="file1407-terminology-x-19">PersistDay</code> and <code id="file1407-terminology-x-20">PersistByteString</code>, respectively.</p>
  <p class="hascomments" id="file1407-terminology-x-21">There&#39;s nothing surprising about those first two mappings, but the last one is interesting.
   There&#39;s no specific constructor for storing PNG content in a database, so instead we use a more
   generic type (a ByteString, which is just a sequence of bytes). We could use the same mechanism
   to store other types of arbitrary data.</p>
  <aside class="note" id="file1407-terminology-x-22">The commonly held best practice for storing images is to keep the data on the filesystem and
   just keep a path to the image in the database. I&#39;m not advocating against that approach here,
   just using database-stored images as an example.</aside>
  <p class="hascomments" id="file1407-terminology-x-23">How is all this represented in the database? Let&#39;s take SQL as an example. The
    <code id="file1407-terminology-x-24">Person</code> entity becomes a table with three columns: name, birthday and picture.
   Each field gets stored as a different SQL type: <code id="file1407-terminology-x-25">Text</code> becomes a
    <code id="file1407-terminology-x-26">VARCHAR</code>, <code id="file1407-terminology-x-27">Day</code> becomes a <code id="file1407-terminology-x-28">Date</code> and
    <code id="file1407-terminology-x-29">PNG</code> becomes a <code id="file1407-terminology-x-30">BLOB</code> (or <code id="file1407-terminology-x-31">BYTEA</code>).</p>
  
 </section><section class="subtopic" id="file1408-type-safety"><h1>Type Safety</h1>
  <p class="hascomments" id="file1408-type-safety-x-3">Persistent handles all of the data marshaling concerns for you behind the scenes. As a user of
   Persistent, you get to completely ignore the fact that a <code id="file1408-type-safety-x-4">Text</code> becomes a
    <code id="file1408-type-safety-x-5">VARCHAR</code>. You&#39;re able to simply declare your datatypes and use them.</p>
  <p class="hascomments" id="file1408-type-safety-x-6">And this is where, yet again, Haskell&#39;s strengths shine through. Every interaction you
   have with Persistent is strongly typed. You can&#39;t accidently put a number in the date fields; the
   compiler won&#39;t accept it. Entire classes of subtle bugs simply disappear at this point.</p>
  <p class="hascomments" id="file1408-type-safety-x-7">Nowhere is this more pronounced than in refactoring. Let&#39;s say you&#39;ve been storing users&#39; ages
   in the database, and you realize that you really wanted to store birthdays instead. You&#39;re able
   to make a single line change to your entities declaration file, hit compile, and automatically
   find every single line of code that needs to be updated.</p>
  <p class="hascomments" id="file1408-type-safety-x-8">In most dynamically-typed languages, and their web frameworks, the recommended approach to
   solving this issue is writing unit tests. If you have full test coverage, then running your tests
   will immediately reveal what code needs to be updated. This is all well and good, but it&#39;s
   definitely a weaker solution than true types:</p>
  <ul id="file1408-type-safety-ul_a07db389-836b-4cef-8d56-d788396d30f9">
   <li id="file1408-type-safety-x-9">It&#39;s all predicated on having full test coverage. This takes extra time, and worse, is
    boilerplate code that the compiler should be able to do for you.</li>
   <li id="file1408-type-safety-x-10">You might be a perfect developer who never forgets to write a test, but can you say the same
    for every person who will touch your codebase?</li>
   <li id="file1408-type-safety-x-11">Even 100% test coverage doesn&#39;t guarantee that you really have tested every case. All it&#39;s
    done is proven you&#39;ve tested every line of code.</li>
  </ul>
 </section><section class="subtopic" id="file1409-persistent-syntax"><h1>Cross-database Syntax</h1>
  <p class="hascomments" id="file1409-persistent-syntax-x-3">Creating a SQL schema that works for multiple SQL engines can be tricky enough. How do you
   create a schema that will also work with a non-SQL database like MongoDB?</p>
  <p class="hascomments" id="file1409-persistent-syntax-x-4">Persistent allows you to define your entities in a high-level syntax, and will automatically
   create the SQL schema for you. (In the case of MongoDB, we currently use a schema-less approach.)
   This also allows Persistent to ensure that your Haskell datatypes match perfectly with the
   database&#39;s definitions.</p>
  <p class="hascomments" id="file1409-persistent-syntax-x-5">Additionally, having all this information gives Persistent the ability to perform more advanced
   functions for you automatically, such as migrations.</p>
 </section><section class="subtopic" id="file1410-migrations"><h1>Migrations</h1>
  <p class="hascomments" id="file1410-migrations-x-3">Persistent not only creates schema files as necessary, but will also automatically
   apply database migrations if possible. Database modification is one of the less-developed pieces
   of the SQL standard, and thus each engine has a different take on the process. As such, each
   Persistent backend defines its own set of migration rules. In PostgreSQL, which has a rich set of
    <code id="file1410-migrations-x-6">ALTER TABLE</code> rules, we use those extensively. Since SQLite lacks much
   of that functionality, we&#39;re reduce to creating temporary tables and copying rows. MongoDB&#39;s
   schema-less approach means no migration support is required.</p>
  <p class="hascomments" id="file1410-migrations-x-4">This feature is purposely limited to prevent any kind of data loss. It will not remove any
   columns automatically; instead, it will give you an error message, telling you the unsafe
   operations that are necessary in order to continue. You will then have the option to either
   manually run the SQL it provides you, or to change your data model to avoid the dangerous
   behavior.</p>
 </section><section class="subtopic" id="file1411-Relations"><h1>Relations</h1>
  <p class="hascomments" id="file1411-Relations-x-3">Persistent is non-relational in nature, meaning it has no requirement for backends to support
   relations. However, in many use cases, we may want to use relations. And in those cases, you will
   have full access to them.</p>
  <p class="hascomments" id="file1411-Relations-x-4">Let&#39;s say we want to now store a list of skills with each user. If we were writing a
   MongoDB-specific app, we could go ahead and just store that list as a new field in the original
   Person entity. But that approach won&#39;t work in SQL. In SQL, we call this kind of relationship a
   one-to-many relationship.</p>
  <p class="hascomments" id="file1411-Relations-x-5">The idea is to store a reference to the &quot;one&quot; entity (person) with each &quot;many&quot; entity (skill).
   Then if we want to find all the skills a person has, we simply find all skills that reference
   that person. For this reference, every entity has an ID. And as you might expect by now, these
   IDs are completely type-safe. The datatype for a Person ID is <code id="file1411-Relations-x-6">PersonId</code>. So to
   add our new skill, we would just add the following to our entity definition:</p>
  <pre class="codeblock" id="file1411-Relations-x-7">Skill
    person PersonId
    name Text
    description Text
    UniqueSkill person name</pre>
  <p class="hascomments" id="file1411-Relations-x-8">This ID datatype concept comes up throughout Persistent and Yesod. You can dispatch based on an
   ID. In such a case, Yesod will automatically marshal the textual representation of the ID to the
   internal one, catching any parse errors along the way. These IDs are used for lookup and deletion
   with the <code id="file1411-Relations-x-9">get</code> and <code id="file1411-Relations-x-10">delete</code> functions, and are returned by the
   insertion and query functions <code id="file1411-Relations-x-11">insert</code> and <code id="file1411-Relations-x-12">selectList</code>.</p>
 </section></section><section class="subtopic" id="file1418-yesod"><h1>Yesod</h1>
  <p class="hascomments" id="file1418-yesod-x-3">If we&#39;re looking through the typical Model-View-Controller (MVC) paradigm, Persistent
   is the model and Sheakespeare is the view. This would leave Yesod as the controller.</p>
  <p class="hascomments" id="file1418-yesod-x-4">The most basic feature of Yesod is routing. This features a declarative syntax and type-safe
   dispatch. Layered on top of this, Yesod provides many other features: streaming content
   generation, widgets, i18n, static files, forms and authentication. But the core feature added by
   Yesod is really routing.</p>
  <p class="hascomments" id="file1418-yesod-x-5">This layered approach makes it simpler for users to swap different components of the system.
   Some people are not interested in using Persistent. For them, nothing in the core system even
   mentions Persistent. Likewise, while commonly used features, not everyone needs authentication or
   static file serving.</p>
  <p class="hascomments" id="file1418-yesod-x-6">On the other hand, many users <i id="file1418-yesod-x-7">will</i> want to integrate all of these features. And doing
   so- while enabling all the optimizations available in Yesod- is not always straightforward. To
   simplify the process, Yesod provides a scaffolding tool as well that sets up a basic site with
   the most commonly used features.</p>
 <section class="subtopic" id="file1414-routes"><h1>Routes</h1>
  <p class="hascomments" id="file1414-routes-x-3">Given that routing is really the main function of Yesod, let&#39;s start there. The routing syntax
   is very simple: a <dfn id="file1414-routes-x-4">resource pattern</dfn>, a name, and request methods. For example, a
   simple blog site might look like:</p>
  <pre class="codeblock" id="file1414-routes-x-5">/ HomepageR GET
/add-entry AddEntryR GET POST
/entry/#EntryId EntryR GET</pre>
  <p class="hascomments" id="file1414-routes-x-6">The first line defines the homepage. This says &quot;I respond to the root path of the domain, I&#39;m
   called HomepageR, and I answer GET requests.&quot;<aside class="note" id="file1414-routes-x-7">The trailing &quot;R&quot; on the resource names is
    simply a convention, it doesn&#39;t hold any special meaning besides giving a cue to the developer
    that something is a route.</aside></p>
  <p class="hascomments" id="file1414-routes-x-8">The second line defines the add entry page. This time, we answer both GET and POST
   requests. You might be wondering why Yesod, as opposed to most frameworks, requires you to
   explicitly state your request methods. The reason is that Yesod tries to adhere to RESTful
   principles as much as possible, and a GET and POST request really have very different meanings.
   Not only do you state these two methods separately, but later you&#39;ll define their handler
   functions separately.</p>
  <aside class="note" id="file1414-routes-x-9">This is actually an optional feature in Yesod. If you want, you can leave off the list of
   methods and your handler function will deal with all methods.</aside>
  <p class="hascomments" id="file1414-routes-x-10">The third line is a bit more interesting. After the second slash we have
    <code id="file1414-routes-x-11">#EntryId</code>. This defines a parameter of type <code id="file1414-routes-x-12">EntryId</code>. In the
   Persistent section, we already alluded to this feature: Yesod will now automatically marshal the
   path component into the relevant ID value. Assuming a SQL backend (we&#39;ll get to Mongo in a
   second), if a user requests <code id="file1414-routes-x-13">/entry/5</code>, the handler function will get called with
   an argument <code id="file1414-routes-x-14">EntryId 5</code>. But if the user requests
    <code id="file1414-routes-x-15">/entry/some-blog-post</code>, Yesod will return a 404.</p>
  <p class="hascomments" id="file1414-routes-x-16">These is obviously possible in most other web frameworks as well. The approach taken by Django,
   for instance, would use a regular expression for matching the routes, e.g.
    <code id="file1414-routes-x-17">r&quot;/entry/(\d+)&quot;</code>. But I think the Yesod approach works better, because:</p>
  <ul id="file1414-routes-ul_b9e08670-a14a-4ad7-833b-20e1e7e38b2d">
   <li id="file1414-routes-x-18">Typing &quot;EntryId&quot; is much more semantic/developer-friendly than some regular expression.</li>
   <li id="file1414-routes-x-19">Regular expressions can&#39;t express everything (or at least, can&#39;t do so succinctly). We can
    use <code id="file1414-routes-x-20">/calendar/#Day</code> in Yesod; do you want to type a regex to match dates in your
    routes?</li>
   <li id="file1414-routes-x-21">Yesod also automatically marshals the data for us. In our calendar case, our handler function
    would receive a <code id="file1414-routes-x-22">Day</code> value. In the Django equivalent, the function would receive
    a piece of text which it would then have to marshal itself. This is tedious, repetitive and
    inefficient.</li>
   <li id="file1414-routes-x-23">So far we&#39;ve assumed that a database ID is just a string of digits. But what if it&#39;s more
    complicated? MongoDB uses GUIDs, for example. In Yesod, your #EntryId will still work, and the
    type system will instruct Yesod how to parse the route. In a regex system, you would have to go
    through all of your routes and change the (\d+) to whatever monstrosity of regex is needed to
    match.</li>
  </ul>
 <section class="subtopic" id="file1413-type-safe-urls"><h1>Type-safe URLs</h1>
  <p class="hascomments" id="file1413-type-safe-urls-x-3">This approach to routing gives birth to one of Yesod&#39;s most powerful features: type-safe URLs.
   Instead of just splicing together pieces of text to refer to a route, every route in your
   application can be represented by a Haskell value. This immediately eliminates a huge number of
   404 not found errors: it&#39;s simply not possible to produce an invalid URL.</p>
  <aside class="note" id="file1413-type-safe-urls-x-4">It&#39;s still possible to produce a 404 URL, such as by referring to a blog post that doesn&#39;t
   exist. However, all URLs will be formed correctly.</aside>
  <p class="hascomments" id="file1413-type-safe-urls-x-5">So how does this magic work? Each site has a route datatype, and each resource pattern gets its
   own constructor. In our previous example, we would get something that looks like:</p>
  <pre class="codeblock"><pre style="padding: 0;margin: 0;"><span style="color: green;font-weight: bold;">data</span> <span style="color: blue;">MySiteRoute</span> = <span style="color: blue;">HomepageR</span>
                 | <span style="color: blue;">AddEntryR</span>
                 | <span style="color: blue;">EntryR</span> <span style="color: blue;">EntryId</span>
</pre></pre>
  <p class="hascomments" id="file1413-type-safe-urls-x-7">If you want to link to the homepage, you use <code id="file1413-type-safe-urls-x-8">HomepageR</code>. To link to a specific
   entry, you would use the <code id="file1413-type-safe-urls-x-9">EntryR</code> constructor with an <code id="file1413-type-safe-urls-x-10">EntryId</code>
   parameter. For example, to create a new entry and redirect to it, you could write:</p>
  <pre class="codeblock"><pre style="padding: 0;margin: 0;"><span style="color: blue;font-weight: bold;">entryId</span> &lt;- insert (<span style="color: blue;">Entry</span> <span style="color: green;">&quot;My Entry&quot;</span> <span style="color: green;">&quot;Some content&quot;</span>)
<span style="color: blue;font-weight: bold;">redirect</span> <span style="color: blue;">RedirectTemporary</span> (<span style="color: blue;">EntryR</span> entryId)
</pre></pre>
  <p class="hascomments" id="file1413-type-safe-urls-x-12">And Hamlet, Lucius and Julius all include built-in support for these type-safe URLs. Inside a
   Hamlet template, you can easily create a link to the add entry page:</p>
  <pre class="codeblock"><pre style="padding: 0;margin: 0;"><span style="color: blue;">&lt;a</span> <span style="color: green;font-weight: bold;">href</span>=@{AddEntryR}<span style="color: blue;">&gt;</span>Create a new entry.
</pre></pre>
  <p class="hascomments" id="file1413-type-safe-urls-x-14">The best part? Just like Persistent entities, the compiler will keep you honest. If you change
   any of your routes (e.g., you want to include the year and month in your entry routes), Yesod
   will force you to update every single reference throughout your codebase.</p>
 </section></section><section class="subtopic" id="file1415-handlers"><h1>Handlers</h1>
  <p class="hascomments" id="file1415-handlers-x-3">Once you define your routes, you need to tell Yesod how you want to respond to requests. This
   is where <dfn id="file1415-handlers-x-4">handler functions</dfn> come into play. The setup is simple, for each resource
   (e.g., HomepageR) and request method, create a function named methodResourceR. For our previous
   example, we would need four functions: <code id="file1415-handlers-x-5">getHomepageR</code>,
    <code id="file1415-handlers-x-6">getAddEntryR</code>, <code id="file1415-handlers-x-7">postAddEntryR</code>, and
   <code id="file1415-handlers-x-8">getEntryR</code>.</p>
  <p class="hascomments" id="file1415-handlers-x-9">All of the parameters collected from the route are passed in as arguments to the handler
   function. <code id="file1415-handlers-x-10">getEntryR</code> will take a first arugment of type EntryId, while all the
   other functions will take no arguments.</p>
  <p class="hascomments" id="file1415-handlers-x-11">The handler functions live in a <code id="file1415-handlers-x-12">Handler</code> monad, which provides a bunch of
   functionality, like redirecting, accessing sessions, and running database queries. For the last
   one, a typical way to start of the <code id="file1415-handlers-x-13">getEntryR</code> function would be:</p>
  <pre class="codeblock" id="file1415-handlers-x-14">getEntryR entryId = do
    entry &lt;- runDB $ get404 entryId</pre>
  <p class="hascomments" id="file1415-handlers-x-15">This will run a database action that will get the entry associated with the given ID from the
   database. If there is no such entry, it will return a 404 response.</p>
  <p class="hascomments" id="file1415-handlers-x-16">Each handler function will return some value, which must be an instance of
    <code id="file1415-handlers-x-17">HasReps</code>. This is another RESTful feature at play: instead of just returning
   some HTML or some JSON, you can return a value that will return either one, depending on the HTTP
   Accept request header. In other words, in Yesod, a resource is a specific piece of data, and it
   can be returned in one of many <dfn id="file1415-handlers-x-18">representations</dfn>.</p>
 </section><section class="subtopic" id="file1416-widgets"><h1>Widgets</h1>
  <p class="hascomments" id="file1416-widgets-x-3">Let&#39;s say you want to include a navbar on a few different pages of your site. This navbar will
   load up the five most recent blog posts (stored in your database), generate some HTML, and then
   need some CSS and Javascript to style and enhance.</p>
  <p class="hascomments" id="file1416-widgets-x-4">Without a higher-level interface to tie these components together, this could be a
   pain. You could add the CSS to the sitewide CSS file, but that&#39;s adding extra declarations you
   don&#39;t always need. Likewise with the Javascript, though a bit worse: having that extra Javascript
   might cause problems on a page it wasn&#39;t intended to live on. You&#39;ll also be breaking modularity
   by having to generate the database results from multiple handler functions.</p>
  <p class="hascomments" id="file1416-widgets-x-5">In Yesod, we have a very simple solution: widgets. A widget is a piece of code that ties
   together HTML, CSS and Javascript, allows you to add content to both the &lt;head&gt; and &lt;body&gt;,
   and can run any arbitrary code that belongs in a handler. For example, to implement our
   navbar:</p>
  <pre class="codeblock"><pre style="padding: 0;margin: 0;"><span style="color: gray;">-- Get last five blog posts. The &quot;lift&quot; says to run this code like we&#39;re in the handler.</span>
<span style="color: blue;font-weight: bold;">entries</span> &lt;- lift $ runDB $ selectList [] [<span style="color: blue;">LimitTo</span> <span style="color: teal;">5</span>, <span style="color: blue;">Desc</span> <span style="color: blue;">EntryPosted</span>]
<span style="color: blue;font-weight: bold;">toWidget</span> [hamlet|
&lt;ul .navbar&gt;
    $forall entry &lt;- entries
        &lt;li&gt;#{entryTitle entry}
|]
<span style="color: blue;font-weight: bold;">toWidget</span> [lucius| .navbar { color: red } |]
<span style="color: blue;font-weight: bold;">toWidget</span> [julius|alert(<span style="color: green;">&quot;Some special Javascript to play with my navbar&quot;</span>);|]
</pre></pre>
  <p class="hascomments" id="file1416-widgets-x-7">But there&#39;s even more power at work here. When you produce a page in Yesod, the standard
   approach is to combine a bunch of widgets together into a single widget containing all your page
   content, and then apply defaultLayout. This function is defined per site, and applies your
   standard site layout.</p>
  <p class="hascomments" id="file1416-widgets-x-8">And where does all of that CSS and Javascript go? Well, that&#39;s up to you, but there are two
   out-of-the-box approaches:</p>
  <ol id="file1416-widgets-ul_d94f42ac-dd25-4a5f-a166-225af4b03c11">
   <li id="file1416-widgets-x-9">Concatenate them and place them into &lt;style&gt; and &lt;script&gt; tags, respectively, within
    your HTML.</li>
   <li id="file1416-widgets-x-10">Place them in external files and refer to them with &lt;link&gt; and &lt;script&gt; tags,
    respectively.</li>
  </ol>
  <p class="hascomments" id="file1416-widgets-x-11">In addition, your Javascript can be automatically minified. Option 2 is the prefered approach,
   since it allows a few extra optimizations:</p>
  <ol id="file1416-widgets-ol_32f7c374-f394-4809-94f5-00480a982d5d">
   <li id="file1416-widgets-x-12">The files are created with names based on a hash of the contents. This means you can place
    cache values far in the future without worries of users receiving stale content.</li>
   <li id="file1416-widgets-x-13">Your Javascript can be asynchronously loaded.</li>
  </ol>
  <p class="hascomments" id="file1416-widgets-x-14">That second point requires a bit of elaboration. Widgets not only contain raw Javascript, they
   also contain a list of Javascript dependencies. For example, many sites will refer to the jQuery
   library and then add some Javascript that uses it. Yesod is able to automatically turn all of
   that into an asynchronous load via yepnope.js.</p>
  <p class="hascomments" id="file1416-widgets-x-15">In other words, widgets allow you to create modular, composable code that will result in
   incredibly efficient serving of your static resources.</p>
 </section><section class="subtopic" id="file1417-subsites"><h1>Subsites</h1>
  <p class="hascomments" id="file1417-subsites-x-3">Many websites share common pieces of functionality. Perhaps the two most common examples of
   this are serving static files and authentication. In Yesod, you can easily drop in this code
   using a <dfn id="file1417-subsites-x-4">subsite</dfn>. All you need to do is add an extra line to your routes. For
   example, to add the static subsite, you would write:</p>
  <pre class="codeblock" id="file1417-subsites-x-5">/static StaticR Static getStatic</pre>
  <p class="hascomments" id="file1417-subsites-x-6">The first argument tells where in the site the subsite starts. The static subsite is usually
   used at /static, but you could use whatever you want. StaticR is the name of the route; this is
   also entirely up to you, but convention is to use StaticR. Static is the name of the static
   subsite; this is one you don&#39;t have control over. And getStatic if a function that returns the
   settings for the static site, such as where the static files are located.</p>
  <p class="hascomments" id="file1417-subsites-x-7">Like all of your handlers, the subsite handlers also have access to the
    <code id="file1417-subsites-x-8">defaultLayout</code> function. This means that a well designed subsite will
   automatically use your site skin without any extra intervention on your part.</p>
 </section></section>
</body>
</html>

